---
phase: 04-color-imagery-tiles
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/components/tiles/ImageryTile.tsx
  - src/components/controls/ImageUpload.tsx
  - src/components/controls/GradientFallback.tsx
autonomous: true

must_haves:
  truths:
    - "Image fills tile edge-to-edge with object-fit cover"
    - "Gradient fallback shows when no image is present"
    - "User can drag-and-drop or click to upload replacement image"
    - "Uploaded images are stored as data URIs in state"
  artifacts:
    - path: "src/components/tiles/ImageryTile.tsx"
      provides: "Imagery tile with cover image and upload trigger"
      exports: ["ImageryTile"]
    - path: "src/components/controls/ImageUpload.tsx"
      provides: "Drag-and-drop file upload with react-dropzone"
      exports: ["ImageUpload"]
    - path: "src/components/controls/GradientFallback.tsx"
      provides: "Gradient placeholder using brand palette"
      exports: ["GradientFallback"]
  key_links:
    - from: "src/components/controls/ImageUpload.tsx"
      to: "react-dropzone"
      via: "useDropzone hook"
      pattern: "useDropzone"
    - from: "src/components/tiles/ImageryTile.tsx"
      to: "src/state/canvasState.ts"
      via: "heroImage and setAssets"
      pattern: "heroImage"
---

<objective>
Build the imagery tile with edge-to-edge cover image display, gradient fallback when no image, and drag-and-drop upload functionality.

Purpose: Users can see their brand imagery and upload replacements. The gradient fallback ensures the tile is always visually interesting even without an image.
Output: ImageryTile component with upload zone and gradient fallback.
</objective>

<execution_context>
@/Users/sannagranqvist/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sannagranqvist/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-color-imagery-tiles/04-RESEARCH.md
@.planning/phases/04-color-imagery-tiles/04-01-SUMMARY.md

# State and types from Plan 01
@src/state/canvasState.ts
@src/types/brand.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create gradient fallback component</name>
  <files>
    src/components/controls/GradientFallback.tsx
  </files>
  <action>
Create `src/components/controls/GradientFallback.tsx` that uses brand palette colors:

```typescript
import { useCanvasStore } from '@/state/canvasState';

interface GradientFallbackProps {
  className?: string;
}

/**
 * Gradient placeholder when no hero image is available.
 * Uses brand palette colors for visual continuity.
 */
export function GradientFallback({ className = '' }: GradientFallbackProps) {
  const palette = useCanvasStore(state => state.assets.palette);

  // Create gradient from primary -> accent with background undertone
  const gradientStyle = {
    background: `
      linear-gradient(
        135deg,
        ${palette.primary}40 0%,
        ${palette.accent}30 50%,
        ${palette.background} 100%
      )
    `,
  };

  return (
    <div
      className={`w-full h-full ${className}`}
      style={gradientStyle}
      aria-label="Placeholder gradient"
    />
  );
}
```

This creates a subtle gradient using the brand colors with reduced opacity (40% and 30%) to keep it from being overwhelming.
  </action>
  <verify>
    `npx tsc --noEmit` passes
    Component renders gradient using palette colors
  </verify>
  <done>
    GradientFallback shows diagonal gradient from primary to accent to background.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create image upload component with react-dropzone</name>
  <files>
    src/components/controls/ImageUpload.tsx
  </files>
  <action>
Create `src/components/controls/ImageUpload.tsx`:

```typescript
import { useDropzone } from 'react-dropzone';
import { useCallback, useState } from 'react';
import { useCanvasStore } from '@/state/canvasState';

const ACCEPTED_IMAGE_TYPES = {
  'image/jpeg': ['.jpg', '.jpeg'],
  'image/png': ['.png'],
  'image/webp': ['.webp'],
};

const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB
const MAX_DIMENSION = 1920; // Resize to max 1920px

interface ImageUploadProps {
  onUploadComplete?: () => void;
  className?: string;
}

/**
 * Resize image to max dimension while maintaining aspect ratio
 */
async function resizeImage(file: File, maxDimension: number): Promise<string> {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();

    reader.onload = () => {
      const img = new Image();

      img.onload = () => {
        // Calculate new dimensions
        let { width, height } = img;

        if (width > maxDimension || height > maxDimension) {
          if (width > height) {
            height = Math.round((height * maxDimension) / width);
            width = maxDimension;
          } else {
            width = Math.round((width * maxDimension) / height);
            height = maxDimension;
          }
        }

        // Create canvas and resize
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;

        const ctx = canvas.getContext('2d');
        if (!ctx) {
          reject(new Error('Failed to get canvas context'));
          return;
        }

        ctx.drawImage(img, 0, 0, width, height);

        // Convert to JPEG with 85% quality for smaller file size
        const dataUri = canvas.toDataURL('image/jpeg', 0.85);
        resolve(dataUri);
      };

      img.onerror = () => reject(new Error('Failed to load image'));
      img.src = reader.result as string;
    };

    reader.onerror = () => reject(new Error('Failed to read file'));
    reader.readAsDataURL(file);
  });
}

export function ImageUpload({ onUploadComplete, className = '' }: ImageUploadProps) {
  const setAssets = useCanvasStore(state => state.setAssets);
  const [error, setError] = useState<string | null>(null);
  const [isProcessing, setIsProcessing] = useState(false);

  const onDrop = useCallback(async (acceptedFiles: File[]) => {
    if (acceptedFiles.length === 0) return;

    const file = acceptedFiles[0];
    setError(null);
    setIsProcessing(true);

    try {
      // Resize image to reduce storage size
      const dataUri = await resizeImage(file, MAX_DIMENSION);

      // Update store
      setAssets({
        heroImage: dataUri,
        imagesSource: 'extracted', // Mark as user-provided
      });

      onUploadComplete?.();
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Upload failed');
    } finally {
      setIsProcessing(false);
    }
  }, [setAssets, onUploadComplete]);

  const { getRootProps, getInputProps, isDragActive, fileRejections } = useDropzone({
    onDrop,
    accept: ACCEPTED_IMAGE_TYPES,
    maxSize: MAX_FILE_SIZE,
    maxFiles: 1,
    multiple: false,
    disabled: isProcessing,
  });

  // Get error message from rejections
  const rejectionError = fileRejections[0]?.errors[0]?.message;
  const displayError = error || rejectionError;

  return (
    <div
      {...getRootProps()}
      className={`
        relative cursor-pointer transition-all duration-200
        ${isDragActive ? 'ring-2 ring-blue-400 ring-inset' : ''}
        ${isProcessing ? 'opacity-50 pointer-events-none' : ''}
        ${className}
      `}
    >
      <input {...getInputProps()} />

      {/* Overlay shown on drag or when empty */}
      <div
        className={`
          absolute inset-0 flex flex-col items-center justify-center
          bg-black/50 backdrop-blur-sm transition-opacity duration-200
          ${isDragActive ? 'opacity-100' : 'opacity-0 hover:opacity-100'}
        `}
      >
        {isProcessing ? (
          <div className="text-white text-sm">Processing...</div>
        ) : isDragActive ? (
          <div className="text-white text-sm font-medium">Drop image here</div>
        ) : (
          <div className="text-center text-white">
            <svg
              className="w-8 h-8 mx-auto mb-2 opacity-80"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={1.5}
                d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"
              />
            </svg>
            <span className="text-sm opacity-80">
              Drag image or click to browse
            </span>
          </div>
        )}
      </div>

      {/* Error display */}
      {displayError && (
        <div className="absolute bottom-2 left-2 right-2 bg-red-500 text-white text-xs px-2 py-1 rounded">
          {displayError}
        </div>
      )}
    </div>
  );
}
```

Key features:
- Accepts JPG, PNG, WebP up to 5MB
- Resizes to max 1920px for smaller data URI storage
- Converts to JPEG at 85% quality
- Shows drag overlay and processing state
- Displays errors from file rejections
  </action>
  <verify>
    `npx tsc --noEmit` passes
    Drop zone accepts files and converts to data URI
    Rejected files show error message
  </verify>
  <done>
    ImageUpload handles drag-and-drop with resize, validation, and error handling.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create ImageryTile component</name>
  <files>
    src/components/tiles/ImageryTile.tsx
  </files>
  <action>
Create `src/components/tiles/ImageryTile.tsx`:

```typescript
import { useCanvasStore } from '@/state/canvasState';
import { GradientFallback } from '@/components/controls/GradientFallback';
import { ImageUpload } from '@/components/controls/ImageUpload';

interface ImageryTileProps {
  className?: string;
}

export function ImageryTile({ className = '' }: ImageryTileProps) {
  const heroImage = useCanvasStore(state => state.assets.heroImage);
  const imagesSource = useCanvasStore(state => state.assets.imagesSource);

  const hasImage = !!heroImage;
  const isDefault = imagesSource === 'default';

  return (
    <div className={`relative overflow-hidden ${className}`}>
      {/* Image layer */}
      {hasImage ? (
        <img
          src={heroImage}
          alt="Brand imagery"
          className="w-full h-full object-cover"
          loading="lazy"
        />
      ) : (
        <GradientFallback />
      )}

      {/* Default indicator */}
      {isDefault && !hasImage && (
        <div className="absolute bottom-2 left-2 text-xs text-white/70 bg-black/30 px-2 py-0.5 rounded">
          Default - click to change
        </div>
      )}

      {/* Upload overlay (always present, shown on hover) */}
      <ImageUpload className="absolute inset-0" />
    </div>
  );
}
```

The tile:
1. Shows hero image with object-fit: cover (edge-to-edge per IMGR-01)
2. Falls back to gradient when no image (per IMGR-02)
3. ImageUpload overlay enables drag-and-drop and click-to-upload (per IMGR-03)
4. Shows "Default - click to change" label when using fallback
  </action>
  <verify>
    `npx tsc --noEmit` passes
    Tile shows image with cover fit when heroImage exists
    Tile shows gradient fallback when no image
    Hover reveals upload overlay
    Drag-and-drop uploads image successfully
  </verify>
  <done>
    ImageryTile displays edge-to-edge image or gradient fallback, with hover-revealed upload zone.
  </done>
</task>

</tasks>

<verification>
1. Types compile: `npx tsc --noEmit` passes
2. Gradient shows: When heroImage is null, gradient displays using palette colors
3. Image cover: When heroImage exists, image fills tile edge-to-edge with object-fit: cover
4. Upload works: Drag image -> processes -> updates store with data URI
5. Click works: Click tile -> file picker opens -> select image -> uploads
6. Resize works: Large images resized to max 1920px, converted to JPEG
7. Validation: Files over 5MB or wrong type show error message
8. Default label: Shows "Default - click to change" when using gradient fallback
</verification>

<success_criteria>
- ImageryTile displays hero image with object-fit: cover (IMGR-01)
- GradientFallback shows when no image using palette.primary -> palette.accent -> palette.background (IMGR-02)
- ImageUpload accepts drag-and-drop for JPG, PNG, WebP (IMGR-03)
- Click-to-upload also works
- Images resized to max 1920px for reasonable data URI size
- File type/size validation with user-visible errors
- "Default - click to change" label shown on fallback
</success_criteria>

<output>
After completion, create `.planning/phases/04-color-imagery-tiles/04-03-SUMMARY.md`
</output>
