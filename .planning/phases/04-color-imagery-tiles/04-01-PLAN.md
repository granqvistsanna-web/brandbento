---
phase: 04-color-imagery-tiles
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/types/brand.ts
  - src/utils/colorContrast.ts
  - src/utils/colorConversion.ts
  - src/utils/paletteGenerator.ts
  - src/state/canvasState.ts
autonomous: true

must_haves:
  truths:
    - "Color palette has semantic roles (primary, accent, background, text)"
    - "WCAG contrast checking returns AA/AAA compliance for color pairs"
    - "Palette presets can be generated from extracted colors"
  artifacts:
    - path: "src/utils/colorContrast.ts"
      provides: "WCAG contrast ratio calculation"
      exports: ["checkContrast", "ContrastResult"]
    - path: "src/utils/colorConversion.ts"
      provides: "HSL to Hex and Hex to HSL conversion"
      exports: ["hslToHex", "hexToHsl"]
    - path: "src/utils/paletteGenerator.ts"
      provides: "Palette preset generation"
      exports: ["generatePalette", "PALETTE_PRESETS"]
    - path: "src/types/brand.ts"
      provides: "ColorPalette and ImageTreatment types"
      contains: "ColorPalette"
  key_links:
    - from: "src/utils/colorContrast.ts"
      to: "color-contrast-checker"
      via: "isLevelAA/isLevelAAA methods"
      pattern: "ColorContrastChecker"
---

<objective>
Install Phase 4 dependencies and create foundational utilities for color manipulation and contrast checking.

Purpose: All color tile features depend on contrast checking, color conversion, and palette generation utilities. These must exist before UI components.
Output: Installed libraries (react-colorful, color-contrast-checker, react-dropzone), extended types, utility functions.
</objective>

<execution_context>
@/Users/sannagranqvist/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sannagranqvist/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-color-imagery-tiles/04-RESEARCH.md

# Current state
@src/types/brand.ts
@src/state/canvasState.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and extend types</name>
  <files>
    package.json
    src/types/brand.ts
  </files>
  <action>
1. Install Phase 4 dependencies:
   ```bash
   npm install react-colorful color-contrast-checker react-dropzone
   ```
   Note: All three have built-in TypeScript types.

2. Extend `src/types/brand.ts` with color palette roles and image treatment types:
   ```typescript
   // Color palette with semantic roles (60-30-10 rule)
   export interface ColorPalette {
     primary: string;        // Main brand color (60% usage)
     accent: string;         // Highlight color (10% usage)
     background: string;     // Surface color (30% usage)
     text: string;           // Body text color
   }

   // Image treatment preset types
   export type ImageTreatment =
     | 'original'
     | 'duotone'
     | 'bw'
     | 'hi-contrast'
     | 'soft'
     | 'grain';

   // Imagery tile state
   export interface ImageryTileState {
     treatment: ImageTreatment;
     colorOverlay: number;   // 0-60 (percentage)
   }
   ```

3. Add ColorPalette to BrandAssets (gradual migration from colors array):
   ```typescript
   export interface BrandAssets {
     // Existing...
     colors: string[];
     colorsSource: 'extracted' | 'default';

     // NEW: Semantic color roles (derived from colors array)
     palette: ColorPalette;

     // Existing...
     primaryFont: string;
     secondaryFont: string;
     fontsSource: 'extracted' | 'default';
     logo: string | null;
     logoSource: 'favicon-svg' | 'favicon-png' | 'apple-touch-icon' | 'favicon-default' | 'header-img' | 'default';
     heroImage: string | null;
     imagesSource: 'extracted' | 'default';

     // NEW: Image treatment state
     imagery: ImageryTileState;
   }
   ```
  </action>
  <verify>
    `npm ls react-colorful color-contrast-checker react-dropzone` shows all installed
    `npx tsc --noEmit` passes
  </verify>
  <done>
    Dependencies installed. Types extended with ColorPalette, ImageTreatment, ImageryTileState.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create color utilities (contrast + conversion)</name>
  <files>
    src/utils/colorContrast.ts
    src/utils/colorConversion.ts
  </files>
  <action>
1. Create `src/utils/colorConversion.ts` for HSL/Hex conversion:
   ```typescript
   export interface HslColor {
     h: number;  // 0-360
     s: number;  // 0-100
     l: number;  // 0-100
   }

   /**
    * Convert hex color to HSL
    * @param hex Color in hex format (#RRGGBB or #RGB)
    */
   export function hexToHsl(hex: string): HslColor {
     // Remove # if present
     hex = hex.replace(/^#/, '');

     // Expand shorthand (#RGB -> #RRGGBB)
     if (hex.length === 3) {
       hex = hex.split('').map(c => c + c).join('');
     }

     const r = parseInt(hex.slice(0, 2), 16) / 255;
     const g = parseInt(hex.slice(2, 4), 16) / 255;
     const b = parseInt(hex.slice(4, 6), 16) / 255;

     const max = Math.max(r, g, b);
     const min = Math.min(r, g, b);
     let h = 0;
     let s = 0;
     const l = (max + min) / 2;

     if (max !== min) {
       const d = max - min;
       s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

       switch (max) {
         case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
         case g: h = ((b - r) / d + 2) / 6; break;
         case b: h = ((r - g) / d + 4) / 6; break;
       }
     }

     return {
       h: Math.round(h * 360),
       s: Math.round(s * 100),
       l: Math.round(l * 100),
     };
   }

   /**
    * Convert HSL to hex color
    */
   export function hslToHex(hsl: HslColor): string {
     const h = hsl.h / 360;
     const s = hsl.s / 100;
     const l = hsl.l / 100;

     let r: number, g: number, b: number;

     if (s === 0) {
       r = g = b = l;
     } else {
       const hue2rgb = (p: number, q: number, t: number) => {
         if (t < 0) t += 1;
         if (t > 1) t -= 1;
         if (t < 1/6) return p + (q - p) * 6 * t;
         if (t < 1/2) return q;
         if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
         return p;
       };

       const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
       const p = 2 * l - q;
       r = hue2rgb(p, q, h + 1/3);
       g = hue2rgb(p, q, h);
       b = hue2rgb(p, q, h - 1/3);
     }

     const toHex = (c: number) => {
       const hex = Math.round(c * 255).toString(16);
       return hex.length === 1 ? '0' + hex : hex;
     };

     return `#${toHex(r)}${toHex(g)}${toHex(b)}`.toUpperCase();
   }

   /**
    * Get hex from RGB values
    */
   export function rgbToHex(r: number, g: number, b: number): string {
     const toHex = (c: number) => {
       const hex = Math.round(c).toString(16);
       return hex.length === 1 ? '0' + hex : hex;
     };
     return `#${toHex(r)}${toHex(g)}${toHex(b)}`.toUpperCase();
   }

   /**
    * Parse hex to RGB values
    */
   export function hexToRgb(hex: string): [number, number, number] {
     hex = hex.replace(/^#/, '');
     if (hex.length === 3) {
       hex = hex.split('').map(c => c + c).join('');
     }
     return [
       parseInt(hex.slice(0, 2), 16),
       parseInt(hex.slice(2, 4), 16),
       parseInt(hex.slice(4, 6), 16),
     ];
   }
   ```

2. Create `src/utils/colorContrast.ts` using color-contrast-checker:
   ```typescript
   import ColorContrastChecker from 'color-contrast-checker';
   import { hexToRgb } from './colorConversion';

   const checker = new ColorContrastChecker();

   export interface ContrastResult {
     ratio: number;
     AA: boolean;      // 4.5:1 for normal text, 3:1 for large
     AAA: boolean;     // 7:1 for normal text, 4.5:1 for large
     level: 'AAA' | 'AA' | 'fail';
   }

   /**
    * Calculate relative luminance per WCAG/ITU-R BT.709
    */
   function getLuminance(hex: string): number {
     const [r, g, b] = hexToRgb(hex);
     const [rs, gs, bs] = [r, g, b].map(val => {
       const normalized = val / 255;
       return normalized <= 0.03928
         ? normalized / 12.92
         : Math.pow((normalized + 0.055) / 1.055, 2.4);
     });
     return 0.2126 * rs + 0.7152 * gs + 0.0722 * bs;
   }

   /**
    * Calculate contrast ratio between two colors
    */
   function calculateContrastRatio(color1: string, color2: string): number {
     const lum1 = getLuminance(color1);
     const lum2 = getLuminance(color2);
     const lighter = Math.max(lum1, lum2);
     const darker = Math.min(lum1, lum2);
     return (lighter + 0.05) / (darker + 0.05);
   }

   /**
    * Check WCAG contrast compliance between text and background colors
    * @param textColor Hex color of text (#RRGGBB)
    * @param bgColor Hex color of background (#RRGGBB)
    * @param fontSize Font size in pixels (affects AA/AAA thresholds)
    */
   export function checkContrast(
     textColor: string,
     bgColor: string,
     fontSize: number = 16
   ): ContrastResult {
     // Normalize hex (remove # if present for BBC library)
     const text = textColor.replace(/^#/, '');
     const bg = bgColor.replace(/^#/, '');

     const AA = checker.isLevelAA(`#${text}`, `#${bg}`, fontSize);
     const AAA = checker.isLevelAAA(`#${text}`, `#${bg}`, fontSize);
     const ratio = calculateContrastRatio(`#${text}`, `#${bg}`);

     return {
       ratio: Math.round(ratio * 100) / 100,
       AA,
       AAA,
       level: AAA ? 'AAA' : AA ? 'AA' : 'fail',
     };
   }

   /**
    * Get appropriate text color (black or white) for a background
    */
   export function getContrastTextColor(bgColor: string): string {
     const luminance = getLuminance(bgColor);
     return luminance > 0.5 ? '#000000' : '#FFFFFF';
   }
   ```
  </action>
  <verify>
    `npx tsc --noEmit` passes
    Create quick test: checkContrast('#FFFFFF', '#000000') returns { ratio: 21, AA: true, AAA: true }
  </verify>
  <done>
    Color conversion utilities handle HSL/Hex/RGB. Contrast checker returns WCAG AA/AAA compliance with ratio.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create palette generator and update state</name>
  <files>
    src/utils/paletteGenerator.ts
    src/state/canvasState.ts
    src/state/defaults.ts
  </files>
  <action>
1. Create `src/utils/paletteGenerator.ts` for preset generation:
   ```typescript
   import type { ColorPalette } from '@/types/brand';
   import { hexToHsl, hslToHex } from './colorConversion';
   import { getContrastTextColor } from './colorContrast';

   export type PalettePresetName =
     | 'original'
     | 'warm'
     | 'cool'
     | 'bold'
     | 'muted'
     | 'editorial';

   export interface PalettePreset {
     name: PalettePresetName;
     label: string;
     generate: (baseColors: string[]) => ColorPalette;
   }

   /**
    * Get most saturated color from array (likely the brand primary)
    */
   function getMostSaturated(colors: string[]): string {
     if (colors.length === 0) return '#2563EB';
     return colors.reduce((best, color) => {
       const bestHsl = hexToHsl(best);
       const colorHsl = hexToHsl(color);
       return colorHsl.s > bestHsl.s ? color : best;
     });
   }

   /**
    * Shift hue by degrees (wraps around 360)
    */
   function shiftHue(hex: string, degrees: number): string {
     const hsl = hexToHsl(hex);
     hsl.h = (hsl.h + degrees + 360) % 360;
     return hslToHex(hsl);
   }

   /**
    * Adjust saturation by multiplier (0-1 reduces, >1 increases)
    */
   function adjustSaturation(hex: string, multiplier: number): string {
     const hsl = hexToHsl(hex);
     hsl.s = Math.min(100, Math.max(0, hsl.s * multiplier));
     return hslToHex(hsl);
   }

   /**
    * Get complementary color (opposite on color wheel)
    */
   function getComplementary(hex: string): string {
     return shiftHue(hex, 180);
   }

   export const PALETTE_PRESETS: PalettePreset[] = [
     {
       name: 'original',
       label: 'Extracted',
       generate: (baseColors) => {
         // Use extracted colors directly, assign roles by saturation/luminance
         const primary = getMostSaturated(baseColors);
         const remaining = baseColors.filter(c => c !== primary);

         // Find darkest for text, lightest for background
         const sorted = [...remaining].sort((a, b) => {
           const aHsl = hexToHsl(a);
           const bHsl = hexToHsl(b);
           return aHsl.l - bHsl.l;
         });

         return {
           primary,
           accent: remaining.length > 1 ? remaining[0] : shiftHue(primary, 30),
           background: sorted[sorted.length - 1] || '#F5F5F5',
           text: sorted[0] || '#111111',
         };
       },
     },
     {
       name: 'warm',
       label: 'Warm Neutral',
       generate: (baseColors) => {
         const primary = shiftHue(getMostSaturated(baseColors), 15);
         return {
           primary,
           accent: shiftHue(primary, -30),
           background: '#FFF9F5',
           text: '#2C1810',
         };
       },
     },
     {
       name: 'cool',
       label: 'Cool Professional',
       generate: (baseColors) => {
         const primary = shiftHue(getMostSaturated(baseColors), -15);
         return {
           primary,
           accent: shiftHue(primary, 30),
           background: '#F5F9FF',
           text: '#0F1C2E',
         };
       },
     },
     {
       name: 'bold',
       label: 'Bold Saturated',
       generate: (baseColors) => {
         const primary = adjustSaturation(getMostSaturated(baseColors), 1.3);
         return {
           primary,
           accent: getComplementary(primary),
           background: '#FFFFFF',
           text: '#000000',
         };
       },
     },
     {
       name: 'muted',
       label: 'Muted Editorial',
       generate: (baseColors) => {
         const primary = adjustSaturation(getMostSaturated(baseColors), 0.5);
         return {
           primary,
           accent: adjustSaturation(shiftHue(primary, 180), 0.4),
           background: '#FFFCF5',
           text: '#1A1814',
         };
       },
     },
   ];

   /**
    * Generate a palette from base colors using a preset
    */
   export function generatePalette(
     baseColors: string[],
     presetName: PalettePresetName = 'original'
   ): ColorPalette {
     const preset = PALETTE_PRESETS.find(p => p.name === presetName) || PALETTE_PRESETS[0];
     return preset.generate(baseColors);
   }

   /**
    * Create default palette from defaults
    */
   export function createDefaultPalette(): ColorPalette {
     return {
       primary: '#2563EB',
       accent: '#7C3AED',
       background: '#F5F5F5',
       text: '#111111',
     };
   }
   ```

2. Update `src/state/defaults.ts` with palette and imagery defaults:
   ```typescript
   import type { BrandAssets, CanvasState, ColorPalette, ImageryTileState } from '@/types/brand';

   export const defaultPalette: ColorPalette = {
     primary: '#2563EB',
     accent: '#7C3AED',
     background: '#F5F5F5',
     text: '#111111',
   };

   export const defaultImagery: ImageryTileState = {
     treatment: 'original',
     colorOverlay: 0,
   };

   export const defaultAssets: BrandAssets = {
     colors: ['#111111', '#555555', '#F5F5F5', '#2563EB', '#FFFFFF'],
     colorsSource: 'default',
     palette: defaultPalette,
     primaryFont: 'Inter',
     secondaryFont: 'Lora',
     fontsSource: 'default',
     logo: null,
     logoSource: 'default',
     heroImage: null,
     imagesSource: 'default',
     imagery: defaultImagery,
   };

   export function createDefaultState(): CanvasState {
     return {
       version: 1,
       sourceUrl: null,
       assets: defaultAssets,
       extractedAt: null,
       lastModified: Date.now(),
     };
   }
   ```

3. Add palette and imagery actions to `src/state/canvasState.ts`:
   ```typescript
   // Add to CanvasStore interface:
   setPalette: (palette: ColorPalette) => void;
   setColorByRole: (role: keyof ColorPalette, color: string) => void;
   setImageTreatment: (treatment: ImageTreatment) => void;
   setColorOverlay: (overlay: number) => void;

   // Add to store implementation:
   setPalette: (palette) => set((state) => ({
     assets: { ...state.assets, palette },
     lastModified: Date.now(),
   })),

   setColorByRole: (role, color) => set((state) => ({
     assets: {
       ...state.assets,
       palette: { ...state.assets.palette, [role]: color },
     },
     lastModified: Date.now(),
   })),

   setImageTreatment: (treatment) => set((state) => ({
     assets: {
       ...state.assets,
       imagery: { ...state.assets.imagery, treatment },
     },
     lastModified: Date.now(),
   })),

   setColorOverlay: (colorOverlay) => set((state) => ({
     assets: {
       ...state.assets,
       imagery: { ...state.assets.imagery, colorOverlay },
     },
     lastModified: Date.now(),
   })),
   ```
  </action>
  <verify>
    `npx tsc --noEmit` passes
    Test: generatePalette(['#FF0000', '#00FF00'], 'warm') returns valid ColorPalette
    Test: Store actions update state correctly
  </verify>
  <done>
    Palette generator creates 5 preset variations. State extended with palette and imagery actions.
  </done>
</task>

</tasks>

<verification>
1. Dependencies installed: `npm ls react-colorful color-contrast-checker react-dropzone` shows versions
2. Types compile: `npx tsc --noEmit` passes
3. Contrast works: checkContrast('#FFFFFF', '#000000') returns high ratio, AAA level
4. Conversion works: hexToHsl('#FF0000') returns { h: 0, s: 100, l: 50 }
5. Presets work: PALETTE_PRESETS.length === 5, each generates valid ColorPalette
6. State works: setPalette and setColorByRole update store correctly
</verification>

<success_criteria>
- react-colorful, color-contrast-checker, react-dropzone in package.json
- ColorPalette and ImageTreatment types exist
- checkContrast returns ContrastResult with AA/AAA flags
- hexToHsl and hslToHex are inverses (round-trip works)
- PALETTE_PRESETS contains 5 presets (original, warm, cool, bold, muted)
- Store has setPalette, setColorByRole, setImageTreatment, setColorOverlay actions
</success_criteria>

<output>
After completion, create `.planning/phases/04-color-imagery-tiles/04-01-SUMMARY.md`
</output>
