---
phase: 03-logo-typography-tiles
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/state/canvasState.ts
  - src/types/brand.ts
  - src/services/luminance.ts
  - src/hooks/useImageLuminance.ts
autonomous: true

must_haves:
  truths:
    - "Undo/redo actions are available via useTemporal hook"
    - "Logo/typography tile state fields exist and persist"
    - "Image luminance can be calculated from any image URL or data URI"
  artifacts:
    - path: "src/state/canvasState.ts"
      provides: "Extended store with temporal middleware and tile state"
      contains: "temporal"
    - path: "src/services/luminance.ts"
      provides: "ITU-R BT.709 luminance calculation"
      exports: ["getImageLuminance", "getAdaptiveBackground"]
    - path: "src/hooks/useImageLuminance.ts"
      provides: "React hook for luminance detection"
      exports: ["useImageLuminance"]
  key_links:
    - from: "src/state/canvasState.ts"
      to: "zundo"
      via: "temporal middleware wrapper"
      pattern: "temporal\\("
---

<objective>
Install Phase 3 dependencies and extend state management with undo/redo capability and logo/typography state fields.

Purpose: Foundation for all Phase 3 editing features - sliders, font changes, logo adjustments all need undo/redo and extended state fields.
Output: Enhanced Zustand store with temporal middleware, luminance detection service, extended type definitions.
</objective>

<execution_context>
@/Users/sannagranqvist/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sannagranqvist/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-logo-typography-tiles/03-RESEARCH.md

# Prior work
@src/state/canvasState.ts
@src/types/brand.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and extend state types</name>
  <files>
    package.json
    src/types/brand.ts
  </files>
  <action>
1. Install Phase 3 dependencies:
   ```bash
   npm install zundo react-window fuse.js
   npm install -D @types/react-window
   ```
   Note: fuse.js has built-in types, no separate @types needed.

2. Extend `src/types/brand.ts` with logo and typography tile state:
   ```typescript
   // Add to BrandAssets or create new interface
   export interface LogoTileState {
     scale: number;           // 40-100
     variant: 'original' | 'dark' | 'light';
     background: 'white' | 'dark' | 'primary' | 'auto';
   }

   export interface TypographyTileState {
     weight: string;          // 'regular', '400', '700', etc.
     sizeScale: number;       // 0.8-1.4 multiplier
     lineHeight: number;      // 1.0-2.0
   }

   export interface TileSettings {
     logo: LogoTileState;
     primaryFont: TypographyTileState;
     secondaryFont: TypographyTileState;
     recentFonts: string[];   // Max 10, for font picker
   }
   ```

3. Add TileSettings to CanvasState interface:
   ```typescript
   export interface CanvasState {
     version: number;
     sourceUrl: string | null;
     assets: BrandAssets;
     tileSettings: TileSettings;  // NEW
     extractedAt: number | null;
     lastModified: number;
   }
   ```
  </action>
  <verify>
    `npm ls zundo react-window fuse.js` shows all installed
    TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>
    Dependencies installed, types extended with LogoTileState, TypographyTileState, TileSettings
  </done>
</task>

<task type="auto">
  <name>Task 2: Add temporal middleware for undo/redo</name>
  <files>
    src/state/canvasState.ts
    src/state/defaults.ts
  </files>
  <action>
1. Update `src/state/defaults.ts` to include default tile settings:
   ```typescript
   export const defaultTileSettings: TileSettings = {
     logo: {
       scale: 70,
       variant: 'original',
       background: 'auto',
     },
     primaryFont: {
       weight: 'regular',
       sizeScale: 1.0,
       lineHeight: 1.2,
     },
     secondaryFont: {
       weight: 'regular',
       sizeScale: 1.0,
       lineHeight: 1.5,
     },
     recentFonts: [],
   };
   ```

2. Wrap the Zustand store with temporal middleware in `src/state/canvasState.ts`:
   ```typescript
   import { temporal } from 'zundo';

   export const useCanvasStore = create<CanvasStore>()(
     temporal(
       subscribeWithSelector((set, get) => ({
         // ... existing state and actions
         tileSettings: defaultTileSettings,

         // Add tile setting actions
         setLogoScale: (scale: number) => set((state) => ({
           tileSettings: {
             ...state.tileSettings,
             logo: { ...state.tileSettings.logo, scale }
           },
           lastModified: Date.now(),
         })),

         setLogoVariant: (variant: 'original' | 'dark' | 'light') => set((state) => ({
           tileSettings: {
             ...state.tileSettings,
             logo: { ...state.tileSettings.logo, variant }
           },
           lastModified: Date.now(),
         })),

         setLogoBackground: (background: 'white' | 'dark' | 'primary' | 'auto') => set((state) => ({
           tileSettings: {
             ...state.tileSettings,
             logo: { ...state.tileSettings.logo, background }
           },
           lastModified: Date.now(),
         })),

         setFontSettings: (role: 'primaryFont' | 'secondaryFont', settings: Partial<TypographyTileState>) => set((state) => ({
           tileSettings: {
             ...state.tileSettings,
             [role]: { ...state.tileSettings[role], ...settings }
           },
           lastModified: Date.now(),
         })),

         addRecentFont: (family: string) => set((state) => {
           const recent = state.tileSettings.recentFonts;
           const updated = [family, ...recent.filter(f => f !== family)].slice(0, 10);
           return {
             tileSettings: {
               ...state.tileSettings,
               recentFonts: updated
             },
             lastModified: Date.now(),
           };
         }),
       })),
       {
         // Zundo configuration
         partialize: (state) => ({
           // Only track these fields for undo/redo
           assets: state.assets,
           tileSettings: state.tileSettings,
         }),
         limit: 30,  // TOOL-05: 30-step undo stack
         equality: (a, b) => JSON.stringify(a) === JSON.stringify(b),
       }
     )
   );

   // Export temporal hook for undo/redo access
   export const useTemporalStore = () => useCanvasStore.temporal.getState();
   ```

3. Update CanvasStore interface with new actions:
   ```typescript
   interface CanvasStore extends CanvasState {
     // ... existing
     setLogoScale: (scale: number) => void;
     setLogoVariant: (variant: 'original' | 'dark' | 'light') => void;
     setLogoBackground: (background: 'white' | 'dark' | 'primary' | 'auto') => void;
     setFontSettings: (role: 'primaryFont' | 'secondaryFont', settings: Partial<TypographyTileState>) => void;
     addRecentFont: (family: string) => void;
   }
   ```
  </action>
  <verify>
    `npx tsc --noEmit` passes
    Create test verifying undo/redo correctness:
    1. Get initial logo scale value (e.g., 70)
    2. Call setLogoScale(50) - scale changes to 50
    3. Call useCanvasStore.temporal.getState().undo()
    4. Verify scale reverts to 70 (not 50)
    5. Call useCanvasStore.temporal.getState().redo()
    6. Verify scale returns to 50
    Run test: verify no runtime errors and state transitions are correct
  </verify>
  <done>
    Zustand store wrapped with temporal middleware, 30-step undo history, partialize excludes transient state, useTemporalStore hook exported, undo() reverts to previous value, redo() restores undone change
  </done>
</task>

<task type="auto">
  <name>Task 3: Create luminance detection service</name>
  <files>
    src/services/luminance.ts
    src/hooks/useImageLuminance.ts
  </files>
  <action>
1. Create `src/services/luminance.ts` with ITU-R BT.709 formula:
   ```typescript
   /**
    * Calculate relative luminance per WCAG/ITU-R BT.709
    * @param r Red channel (0-255)
    * @param g Green channel (0-255)
    * @param b Blue channel (0-255)
    * @returns Luminance value (0-1)
    */
   function getLuminance(r: number, g: number, b: number): number {
     const [rs, gs, bs] = [r, g, b].map(val => {
       const normalized = val / 255;
       return normalized <= 0.03928
         ? normalized / 12.92
         : Math.pow((normalized + 0.055) / 1.055, 2.4);
     });
     return 0.2126 * rs + 0.7152 * gs + 0.0722 * bs;
   }

   /**
    * Get average luminance from image URL or data URI
    * Handles SVG data URIs by waiting for Image onload
    */
   export async function getImageLuminance(
     imageUrl: string,
     sampleSize = 10  // Sample every Nth pixel
   ): Promise<number> {
     return new Promise((resolve, reject) => {
       const img = new Image();
       img.crossOrigin = 'anonymous';

       img.onload = () => {
         try {
           const canvas = document.createElement('canvas');
           const ctx = canvas.getContext('2d');

           if (!ctx) {
             reject(new Error('Canvas context not available'));
             return;
           }

           // Resize to small canvas for performance
           const maxSize = 100;
           const scale = Math.min(maxSize / img.width, maxSize / img.height, 1);
           canvas.width = Math.max(1, img.width * scale);
           canvas.height = Math.max(1, img.height * scale);

           ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

           const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
           const data = imageData.data;

           let totalLuminance = 0;
           let count = 0;

           // Sample pixels
           for (let i = 0; i < data.length; i += 4 * sampleSize) {
             const r = data[i];
             const g = data[i + 1];
             const b = data[i + 2];
             const a = data[i + 3];

             // Skip transparent pixels
             if (a < 128) continue;

             totalLuminance += getLuminance(r, g, b);
             count++;
           }

           resolve(count > 0 ? totalLuminance / count : 0.5);
         } catch (error) {
           reject(error);
         }
       };

       img.onerror = () => {
         reject(new Error('Failed to load image for luminance detection'));
       };

       img.src = imageUrl;
     });
   }

   /**
    * Determine background color based on logo luminance
    * High luminance (bright logo) -> dark background
    * Low luminance (dark logo) -> light background
    */
   export function getAdaptiveBackground(luminance: number): 'light' | 'dark' {
     return luminance > 0.5 ? 'dark' : 'light';
   }
   ```

2. Create `src/hooks/useImageLuminance.ts`:
   ```typescript
   import { useState, useEffect } from 'react';
   import { getImageLuminance, getAdaptiveBackground } from '@/services/luminance';

   interface UseImageLuminanceResult {
     luminance: number | null;
     background: 'light' | 'dark';
     loading: boolean;
     error: string | null;
   }

   export function useImageLuminance(imageUrl: string | null): UseImageLuminanceResult {
     const [luminance, setLuminance] = useState<number | null>(null);
     const [background, setBackground] = useState<'light' | 'dark'>('light');
     const [loading, setLoading] = useState(false);
     const [error, setError] = useState<string | null>(null);

     useEffect(() => {
       if (!imageUrl) {
         setLuminance(null);
         setBackground('light');
         setError(null);
         return;
       }

       setLoading(true);
       setError(null);

       getImageLuminance(imageUrl)
         .then(l => {
           setLuminance(l);
           setBackground(getAdaptiveBackground(l));
         })
         .catch(err => {
           console.warn('Luminance detection failed:', err);
           setError(err.message);
           setLuminance(null);
           setBackground('light');  // Fallback to light
         })
         .finally(() => setLoading(false));
     }, [imageUrl]);

     return { luminance, background, loading, error };
   }
   ```
  </action>
  <verify>
    TypeScript compiles: `npx tsc --noEmit`
    Create quick test in App.tsx: useImageLuminance with a known image URL, log result
  </verify>
  <done>
    Luminance service calculates brightness using Canvas API with ITU-R BT.709 formula, handles SVG data URIs, hook provides reactive background recommendation
  </done>
</task>

</tasks>

<verification>
1. Dependencies installed: `npm ls zundo react-window fuse.js` shows versions
2. Types compile: `npx tsc --noEmit` passes
3. Store works: Import useCanvasStore, call setLogoScale(50), verify state updates
4. Undo works: Import useTemporalStore, call undo(), verify state reverts to specific prior value
5. Redo works: Call redo(), verify state returns to value before undo
6. Luminance works: Hook returns 'light' or 'dark' for test images
</verification>

<success_criteria>
- zundo, react-window, fuse.js installed in package.json
- TileSettings type with logo/typography state exists
- Zustand store wrapped with temporal middleware
- useTemporalStore hook exported for undo/redo access
- getImageLuminance returns 0-1 value for any image
- useImageLuminance hook returns adaptive background
</success_criteria>

<output>
After completion, create `.planning/phases/03-logo-typography-tiles/03-01-SUMMARY.md`
</output>
