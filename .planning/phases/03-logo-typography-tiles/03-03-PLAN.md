---
phase: 03-logo-typography-tiles
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/services/googleFonts.ts
  - src/hooks/useGoogleFonts.ts
  - src/hooks/useFontSearch.ts
  - src/hooks/useHoverPreview.ts
  - src/components/pickers/FontPicker.tsx
  - src/components/pickers/FontPickerList.tsx
  - src/data/googleFontsMetadata.ts
autonomous: true

must_haves:
  truths:
    - "Font picker opens with search-as-you-type"
    - "Category filters (sans, serif, display, mono) work"
    - "Popular fonts (~20) shown by default"
    - "Recently used fonts pinned to top"
    - "Font names render in their own typeface"
    - "Font preview appears within 2 seconds of hover"
    - "System fallback shown when font fails to load"
  artifacts:
    - path: "src/services/googleFonts.ts"
      provides: "Google Fonts API v2 loading functions"
      exports: ["loadFont", "buildFontURL", "loadFontWithFallback"]
    - path: "src/components/pickers/FontPicker.tsx"
      provides: "Complete font picker with search and filters"
      min_lines: 100
    - path: "src/components/pickers/FontPickerList.tsx"
      provides: "Virtualized font list with react-window"
      min_lines: 50
    - path: "src/hooks/useHoverPreview.ts"
      provides: "Hover preview without state commit"
      exports: ["useHoverPreview"]
  key_links:
    - from: "src/components/pickers/FontPickerList.tsx"
      to: "react-window"
      via: "FixedSizeList import"
      pattern: "FixedSizeList"
    - from: "src/hooks/useFontSearch.ts"
      to: "fuse.js"
      via: "Fuse import for fuzzy search"
      pattern: "new Fuse"
---

<objective>
Build the Google Fonts service and complete font picker component with search, filters, virtualized list, and hover preview.

Purpose: Font picker is the core interaction for typography tiles - needs search, category filters, 1600+ font support, and live preview.
Output: googleFonts service, FontPicker component with search/filters, virtualized list, hover preview hook.
</objective>

<execution_context>
@/Users/sannagranqvist/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sannagranqvist/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-logo-typography-tiles/03-RESEARCH.md

# Prior plan (dependencies, state)
@.planning/phases/03-logo-typography-tiles/03-01-PLAN.md

@src/state/canvasState.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Google Fonts service and font metadata</name>
  <files>
    src/services/googleFonts.ts
    src/data/googleFontsMetadata.ts
    src/hooks/useGoogleFonts.ts
  </files>
  <action>
1. Create `src/data/googleFontsMetadata.ts` with popular fonts subset:
   ```typescript
   export interface GoogleFontMeta {
     family: string;
     category: 'sans-serif' | 'serif' | 'display' | 'handwriting' | 'monospace';
     variants: string[];
   }

   // Top ~200 fonts for MVP, full list can be fetched from API later
   // Categories: sans-serif, serif, display, handwriting, monospace
   export const GOOGLE_FONTS: GoogleFontMeta[] = [
     // Sans-serif (most popular)
     { family: 'Inter', category: 'sans-serif', variants: ['100', '200', '300', '400', '500', '600', '700', '800', '900'] },
     { family: 'Roboto', category: 'sans-serif', variants: ['100', '300', '400', '500', '700', '900'] },
     { family: 'Open Sans', category: 'sans-serif', variants: ['300', '400', '500', '600', '700', '800'] },
     { family: 'Lato', category: 'sans-serif', variants: ['100', '300', '400', '700', '900'] },
     { family: 'Montserrat', category: 'sans-serif', variants: ['100', '200', '300', '400', '500', '600', '700', '800', '900'] },
     { family: 'Poppins', category: 'sans-serif', variants: ['100', '200', '300', '400', '500', '600', '700', '800', '900'] },
     { family: 'Raleway', category: 'sans-serif', variants: ['100', '200', '300', '400', '500', '600', '700', '800', '900'] },
     { family: 'Nunito', category: 'sans-serif', variants: ['200', '300', '400', '500', '600', '700', '800', '900'] },
     { family: 'Ubuntu', category: 'sans-serif', variants: ['300', '400', '500', '700'] },
     { family: 'Work Sans', category: 'sans-serif', variants: ['100', '200', '300', '400', '500', '600', '700', '800', '900'] },
     { family: 'Noto Sans', category: 'sans-serif', variants: ['100', '200', '300', '400', '500', '600', '700', '800', '900'] },
     { family: 'Rubik', category: 'sans-serif', variants: ['300', '400', '500', '600', '700', '800', '900'] },
     { family: 'Oswald', category: 'sans-serif', variants: ['200', '300', '400', '500', '600', '700'] },
     { family: 'Source Sans 3', category: 'sans-serif', variants: ['200', '300', '400', '500', '600', '700', '800', '900'] },
     { family: 'Mukta', category: 'sans-serif', variants: ['200', '300', '400', '500', '600', '700', '800'] },
     { family: 'PT Sans', category: 'sans-serif', variants: ['400', '700'] },
     { family: 'Quicksand', category: 'sans-serif', variants: ['300', '400', '500', '600', '700'] },
     { family: 'Manrope', category: 'sans-serif', variants: ['200', '300', '400', '500', '600', '700', '800'] },
     { family: 'DM Sans', category: 'sans-serif', variants: ['400', '500', '700'] },
     { family: 'Outfit', category: 'sans-serif', variants: ['100', '200', '300', '400', '500', '600', '700', '800', '900'] },

     // Serif
     { family: 'Lora', category: 'serif', variants: ['400', '500', '600', '700'] },
     { family: 'Playfair Display', category: 'serif', variants: ['400', '500', '600', '700', '800', '900'] },
     { family: 'Merriweather', category: 'serif', variants: ['300', '400', '700', '900'] },
     { family: 'PT Serif', category: 'serif', variants: ['400', '700'] },
     { family: 'Libre Baskerville', category: 'serif', variants: ['400', '700'] },
     { family: 'Crimson Text', category: 'serif', variants: ['400', '600', '700'] },
     { family: 'EB Garamond', category: 'serif', variants: ['400', '500', '600', '700', '800'] },
     { family: 'Bitter', category: 'serif', variants: ['100', '200', '300', '400', '500', '600', '700', '800', '900'] },
     { family: 'Source Serif 4', category: 'serif', variants: ['200', '300', '400', '500', '600', '700', '800', '900'] },
     { family: 'Noto Serif', category: 'serif', variants: ['400', '700'] },
     { family: 'Cormorant Garamond', category: 'serif', variants: ['300', '400', '500', '600', '700'] },
     { family: 'Spectral', category: 'serif', variants: ['200', '300', '400', '500', '600', '700', '800'] },
     { family: 'Vollkorn', category: 'serif', variants: ['400', '500', '600', '700', '800', '900'] },
     { family: 'DM Serif Display', category: 'serif', variants: ['400'] },
     { family: 'Fraunces', category: 'serif', variants: ['100', '200', '300', '400', '500', '600', '700', '800', '900'] },

     // Display
     { family: 'Bebas Neue', category: 'display', variants: ['400'] },
     { family: 'Abril Fatface', category: 'display', variants: ['400'] },
     { family: 'Righteous', category: 'display', variants: ['400'] },
     { family: 'Lobster', category: 'display', variants: ['400'] },
     { family: 'Alfa Slab One', category: 'display', variants: ['400'] },
     { family: 'Fredoka', category: 'display', variants: ['300', '400', '500', '600', '700'] },
     { family: 'Archivo Black', category: 'display', variants: ['400'] },
     { family: 'Lilita One', category: 'display', variants: ['400'] },
     { family: 'Passion One', category: 'display', variants: ['400', '700', '900'] },
     { family: 'Permanent Marker', category: 'display', variants: ['400'] },

     // Monospace
     { family: 'Roboto Mono', category: 'monospace', variants: ['100', '200', '300', '400', '500', '600', '700'] },
     { family: 'Fira Code', category: 'monospace', variants: ['300', '400', '500', '600', '700'] },
     { family: 'JetBrains Mono', category: 'monospace', variants: ['100', '200', '300', '400', '500', '600', '700', '800'] },
     { family: 'Source Code Pro', category: 'monospace', variants: ['200', '300', '400', '500', '600', '700', '800', '900'] },
     { family: 'IBM Plex Mono', category: 'monospace', variants: ['100', '200', '300', '400', '500', '600', '700'] },
     { family: 'Space Mono', category: 'monospace', variants: ['400', '700'] },
     { family: 'Ubuntu Mono', category: 'monospace', variants: ['400', '700'] },
     { family: 'Inconsolata', category: 'monospace', variants: ['200', '300', '400', '500', '600', '700', '800', '900'] },

     // Handwriting
     { family: 'Dancing Script', category: 'handwriting', variants: ['400', '500', '600', '700'] },
     { family: 'Pacifico', category: 'handwriting', variants: ['400'] },
     { family: 'Caveat', category: 'handwriting', variants: ['400', '500', '600', '700'] },
     { family: 'Satisfy', category: 'handwriting', variants: ['400'] },
     { family: 'Great Vibes', category: 'handwriting', variants: ['400'] },
   ];

   export const POPULAR_FONTS = [
     'Inter', 'Roboto', 'Open Sans', 'Lato', 'Montserrat',
     'Poppins', 'Raleway', 'Nunito', 'Playfair Display', 'Merriweather',
     'PT Sans', 'Ubuntu', 'Work Sans', 'Noto Sans', 'Mukta',
     'Rubik', 'Oswald', 'Source Sans 3', 'Libre Baskerville', 'Crimson Text'
   ];
   ```

2. Create `src/services/googleFonts.ts`:
   ```typescript
   const loadedFonts = new Set<string>();

   /**
    * Build Google Fonts CSS API v2 URL
    */
   export function buildFontURL(
     family: string,
     weights: string[] = ['400'],
     display: 'swap' | 'block' | 'auto' = 'swap'
   ): string {
     const encodedFamily = family.replace(/ /g, '+');
     const weightSpec = weights.sort((a, b) => parseInt(a) - parseInt(b)).join(';');
     return `https://fonts.googleapis.com/css2?family=${encodedFamily}:wght@${weightSpec}&display=${display}`;
   }

   /**
    * Load font by injecting <link> tag
    */
   export function loadFont(family: string, weights: string[] = ['400']): Promise<void> {
     return new Promise((resolve, reject) => {
       // Check cache
       const cacheKey = `${family}:${weights.join(',')}`;
       if (loadedFonts.has(cacheKey)) {
         resolve();
         return;
       }

       const url = buildFontURL(family, weights);

       // Check if link already exists
       const existing = document.querySelector(`link[href="${url}"]`);
       if (existing) {
         loadedFonts.add(cacheKey);
         resolve();
         return;
       }

       const link = document.createElement('link');
       link.rel = 'stylesheet';
       link.href = url;

       link.onload = () => {
         document.fonts.ready.then(() => {
           loadedFonts.add(cacheKey);
           resolve();
         });
       };

       link.onerror = () => {
         reject(new Error(`Failed to load font: ${family}`));
       };

       document.head.appendChild(link);
     });
   }

   /**
    * Load font with timeout and fallback
    */
   export async function loadFontWithFallback(
     family: string,
     weights: string[] = ['400'],
     timeout = 3000
   ): Promise<{ loaded: boolean; error?: string }> {
     try {
       await Promise.race([
         loadFont(family, weights),
         new Promise((_, reject) =>
           setTimeout(() => reject(new Error('Font load timeout')), timeout)
         )
       ]);
       return { loaded: true };
     } catch (error) {
       console.warn(`Font load failed: ${family}`, error);
       return { loaded: false, error: (error as Error).message };
     }
   }

   /**
    * Get system fallback for category
    */
   export function getSystemFallback(category: string): string {
     switch (category) {
       case 'serif':
         return 'Georgia, "Times New Roman", serif';
       case 'monospace':
         return '"Courier New", Courier, monospace';
       case 'display':
       case 'handwriting':
         return 'system-ui, sans-serif';
       default:
         return 'system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
     }
   }
   ```

3. Create `src/hooks/useGoogleFonts.ts`:
   ```typescript
   import { useState, useEffect, useCallback } from 'react';
   import { loadFontWithFallback, getSystemFallback } from '@/services/googleFonts';
   import { GOOGLE_FONTS, type GoogleFontMeta } from '@/data/googleFontsMetadata';

   interface UseGoogleFontsResult {
     loading: boolean;
     error: string | null;
     fontFamily: string;
     loadFont: (family: string, weights?: string[]) => Promise<boolean>;
   }

   export function useGoogleFonts(
     family: string,
     category: GoogleFontMeta['category'] = 'sans-serif'
   ): UseGoogleFontsResult {
     const [loading, setLoading] = useState(false);
     const [error, setError] = useState<string | null>(null);
     const [loadedFamily, setLoadedFamily] = useState<string | null>(null);

     const fallback = getSystemFallback(category);
     const fontFamily = loadedFamily ? `"${loadedFamily}", ${fallback}` : fallback;

     const loadFontAsync = useCallback(async (fontFamily: string, weights?: string[]) => {
       setLoading(true);
       setError(null);

       const fontMeta = GOOGLE_FONTS.find(f => f.family === fontFamily);
       const weightsToLoad = weights || (fontMeta?.variants.filter(v => !v.includes('italic')) || ['400']);

       const result = await loadFontWithFallback(fontFamily, weightsToLoad);

       setLoading(false);

       if (result.loaded) {
         setLoadedFamily(fontFamily);
         return true;
       } else {
         setError(result.error || 'Failed to load font');
         return false;
       }
     }, []);

     // Auto-load on family change
     useEffect(() => {
       if (family) {
         loadFontAsync(family);
       }
     }, [family, loadFontAsync]);

     return { loading, error, fontFamily, loadFont: loadFontAsync };
   }
   ```
  </action>
  <verify>
    TypeScript compiles: `npx tsc --noEmit`
    Import loadFont in App.tsx, call loadFont('Inter', ['400']), verify font loads (check Network tab)
  </verify>
  <done>
    Google Fonts service loads fonts via CSS API v2, caches loaded fonts, provides system fallback, useGoogleFonts hook auto-loads on family change
  </done>
</task>

<task type="auto">
  <name>Task 2: Create hover preview hook and font search hook</name>
  <files>
    src/hooks/useHoverPreview.ts
    src/hooks/useFontSearch.ts
  </files>
  <action>
1. Create `src/hooks/useHoverPreview.ts`:
   ```typescript
   import { useState, useCallback } from 'react';

   interface UseHoverPreviewResult<T> {
     activeValue: T;
     isPreview: boolean;
     startPreview: (value: T) => void;
     endPreview: () => void;
     commit: (value: T, onCommit: (value: T) => void) => void;
   }

   /**
    * Hook for hover preview pattern
    * Shows temporary preview without committing to state until clicked
    */
   export function useHoverPreview<T>(committedValue: T): UseHoverPreviewResult<T> {
     const [previewValue, setPreviewValue] = useState<T | null>(null);

     const startPreview = useCallback((value: T) => {
       setPreviewValue(value);
     }, []);

     const endPreview = useCallback(() => {
       setPreviewValue(null);
     }, []);

     const commit = useCallback((value: T, onCommit: (value: T) => void) => {
       onCommit(value);
       setPreviewValue(null);
     }, []);

     const activeValue = previewValue !== null ? previewValue : committedValue;

     return {
       activeValue,
       isPreview: previewValue !== null,
       startPreview,
       endPreview,
       commit
     };
   }
   ```

2. Create `src/hooks/useFontSearch.ts`:
   ```typescript
   import { useMemo, useState, useCallback } from 'react';
   import Fuse from 'fuse.js';
   import { GOOGLE_FONTS, POPULAR_FONTS, type GoogleFontMeta } from '@/data/googleFontsMetadata';

   type FontCategory = GoogleFontMeta['category'] | null;

   interface UseFontSearchResult {
     fonts: GoogleFontMeta[];
     searchQuery: string;
     setSearchQuery: (query: string) => void;
     categoryFilter: FontCategory;
     setCategoryFilter: (category: FontCategory) => void;
     recentCount: number;
   }

   export function useFontSearch(recentlyUsed: string[] = []): UseFontSearchResult {
     const [searchQuery, setSearchQuery] = useState('');
     const [categoryFilter, setCategoryFilter] = useState<FontCategory>(null);

     // Configure fuzzy search
     const fuse = useMemo(
       () => new Fuse(GOOGLE_FONTS, {
         keys: ['family'],
         threshold: 0.3,
         distance: 100
       }),
       []
     );

     // Filter and search
     const filteredFonts = useMemo(() => {
       let result = [...GOOGLE_FONTS];

       // Category filter
       if (categoryFilter) {
         result = result.filter(f => f.category === categoryFilter);
       }

       // Search query
       if (searchQuery.trim()) {
         const searchResults = fuse.search(searchQuery);
         result = searchResults.map(r => r.item);
       } else if (!categoryFilter) {
         // No search and no filter: show popular fonts first
         const popular = result.filter(f => POPULAR_FONTS.includes(f.family));
         const rest = result.filter(f => !POPULAR_FONTS.includes(f.family));
         result = [...popular, ...rest];
       }

       return result;
     }, [categoryFilter, searchQuery, fuse]);

     // Organize: Recently Used at top
     const organizedFonts = useMemo(() => {
       if (recentlyUsed.length === 0) return filteredFonts;

       const recent = filteredFonts.filter(f => recentlyUsed.includes(f.family));
       const rest = filteredFonts.filter(f => !recentlyUsed.includes(f.family));

       return [
         ...recent.sort((a, b) =>
           recentlyUsed.indexOf(a.family) - recentlyUsed.indexOf(b.family)
         ),
         ...rest
       ];
     }, [filteredFonts, recentlyUsed]);

     return {
       fonts: organizedFonts,
       searchQuery,
       setSearchQuery,
       categoryFilter,
       setCategoryFilter,
       recentCount: recentlyUsed.length
     };
   }
   ```
  </action>
  <verify>
    TypeScript compiles: `npx tsc --noEmit`
    Import useFontSearch, call with empty array, verify fonts array contains GOOGLE_FONTS
    Set searchQuery to "rob", verify filtered results include "Roboto"
  </verify>
  <done>
    useHoverPreview provides preview/commit pattern, useFontSearch provides fuzzy search with Fuse.js and category filters
  </done>
</task>

<task type="auto">
  <name>Task 3: Create FontPicker with virtualized list</name>
  <files>
    src/components/pickers/FontPicker.tsx
    src/components/pickers/FontPickerList.tsx
    src/components/pickers/index.ts
  </files>
  <action>
1. Create `src/components/pickers/FontPickerList.tsx`:
   ```typescript
   import { memo, useCallback, useEffect, useRef } from 'react';
   import { FixedSizeList as List } from 'react-window';
   import type { GoogleFontMeta } from '@/data/googleFontsMetadata';
   import { loadFont } from '@/services/googleFonts';

   interface FontPickerListProps {
     fonts: GoogleFontMeta[];
     selectedFont: string;
     recentFonts: string[];
     onSelect: (family: string) => void;
     onHover: (family: string | null) => void;
     height: number;
   }

   const ITEM_HEIGHT = 48;

   // Track which fonts have been loaded for preview
   const previewLoadedFonts = new Set<string>();

   export const FontPickerList = memo(function FontPickerList({
     fonts,
     selectedFont,
     recentFonts,
     onSelect,
     onHover,
     height
   }: FontPickerListProps) {
     const listRef = useRef<List>(null);

     // Load font when hovering for preview
     const handleHover = useCallback((family: string | null) => {
       if (family && !previewLoadedFonts.has(family)) {
         loadFont(family, ['400']).then(() => {
           previewLoadedFonts.add(family);
         }).catch(() => {
           // Ignore preview load failures
         });
       }
       onHover(family);
     }, [onHover]);

     // Row renderer
     const Row = useCallback(({ index, style }: { index: number; style: React.CSSProperties }) => {
       const font = fonts[index];
       const isSelected = font.family === selectedFont;
       const isRecent = recentFonts.includes(font.family);
       const isLoaded = previewLoadedFonts.has(font.family);

       return (
         <div
           style={style}
           className={`font-picker-row ${isSelected ? 'selected' : ''}`}
           onClick={() => onSelect(font.family)}
           onMouseEnter={() => handleHover(font.family)}
           onMouseLeave={() => handleHover(null)}
           role="option"
           aria-selected={isSelected}
         >
           <span
             className="font-name"
             style={{
               fontFamily: isLoaded ? `"${font.family}", system-ui` : 'system-ui'
             }}
           >
             {font.family}
           </span>
           <div className="font-meta">
             {isRecent && <span className="font-badge recent">Recent</span>}
             <span className="font-category">{font.category}</span>
           </div>
         </div>
       );
     }, [fonts, selectedFont, recentFonts, onSelect, handleHover]);

     return (
       <List
         ref={listRef}
         height={height}
         itemCount={fonts.length}
         itemSize={ITEM_HEIGHT}
         width="100%"
         overscanCount={5}
       >
         {Row}
       </List>
     );
   });
   ```

2. Create `src/components/pickers/FontPicker.tsx`:
   ```typescript
   import { useState, useEffect } from 'react';
   import { useFontSearch } from '@/hooks/useFontSearch';
   import { useHoverPreview } from '@/hooks/useHoverPreview';
   import { FontPickerList } from './FontPickerList';
   import type { GoogleFontMeta } from '@/data/googleFontsMetadata';

   interface FontPickerProps {
     currentFont: string;
     recentFonts: string[];
     onSelect: (family: string) => void;
     onPreviewChange?: (family: string | null) => void;
     height?: number;
   }

   type CategoryFilter = GoogleFontMeta['category'] | null;

   const CATEGORY_OPTIONS: { value: CategoryFilter; label: string }[] = [
     { value: null, label: 'All' },
     { value: 'sans-serif', label: 'Sans' },
     { value: 'serif', label: 'Serif' },
     { value: 'display', label: 'Display' },
     { value: 'monospace', label: 'Mono' },
   ];

   export function FontPicker({
     currentFont,
     recentFonts,
     onSelect,
     onPreviewChange,
     height = 320
   }: FontPickerProps) {
     const {
       fonts,
       searchQuery,
       setSearchQuery,
       categoryFilter,
       setCategoryFilter
     } = useFontSearch(recentFonts);

     const {
       activeValue,
       isPreview,
       startPreview,
       endPreview,
       commit
     } = useHoverPreview(currentFont);

     // Notify parent of preview changes
     useEffect(() => {
       if (onPreviewChange) {
         onPreviewChange(isPreview ? activeValue : null);
       }
     }, [activeValue, isPreview, onPreviewChange]);

     const handleSelect = (family: string) => {
       commit(family, onSelect);
     };

     const handleHover = (family: string | null) => {
       if (family) {
         startPreview(family);
       } else {
         endPreview();
       }
     };

     return (
       <div className="font-picker">
         {/* Search input */}
         <div className="font-picker-search">
           <input
             type="text"
             placeholder="Search fonts..."
             value={searchQuery}
             onChange={(e) => setSearchQuery(e.target.value)}
             className="font-search-input"
             autoFocus
           />
         </div>

         {/* Category filters */}
         <div className="font-picker-filters">
           {CATEGORY_OPTIONS.map(option => (
             <button
               key={option.value || 'all'}
               type="button"
               className={`filter-button ${categoryFilter === option.value ? 'active' : ''}`}
               onClick={() => setCategoryFilter(option.value)}
             >
               {option.label}
             </button>
           ))}
         </div>

         {/* Font count */}
         <div className="font-picker-count">
           {fonts.length} font{fonts.length !== 1 ? 's' : ''}
           {recentFonts.length > 0 && ` (${recentFonts.length} recent)`}
         </div>

         {/* Virtualized list */}
         <div className="font-picker-list">
           <FontPickerList
             fonts={fonts}
             selectedFont={currentFont}
             recentFonts={recentFonts}
             onSelect={handleSelect}
             onHover={handleHover}
             height={height}
           />
         </div>
       </div>
     );
   }
   ```

3. Add CSS for font picker:
   ```css
   .font-picker {
     display: flex;
     flex-direction: column;
     gap: 12px;
   }

   .font-picker-search {
     padding: 0 4px;
   }

   .font-search-input {
     width: 100%;
     padding: 10px 12px;
     border: 1px solid #e0e0e0;
     border-radius: 8px;
     font-size: 14px;
   }

   .font-search-input:focus {
     outline: none;
     border-color: #111;
   }

   .font-picker-filters {
     display: flex;
     gap: 4px;
     padding: 0 4px;
   }

   .filter-button {
     flex: 1;
     padding: 6px 8px;
     border: 1px solid #e0e0e0;
     background: white;
     border-radius: 6px;
     font-size: 12px;
     cursor: pointer;
     transition: all 150ms ease;
   }

   .filter-button:hover {
     background: #f5f5f5;
   }

   .filter-button.active {
     background: #111;
     color: white;
     border-color: #111;
   }

   .font-picker-count {
     font-size: 12px;
     color: #888;
     padding: 0 8px;
   }

   .font-picker-list {
     border: 1px solid #e0e0e0;
     border-radius: 8px;
     overflow: hidden;
   }

   .font-picker-row {
     display: flex;
     align-items: center;
     justify-content: space-between;
     padding: 0 12px;
     cursor: pointer;
     transition: background 100ms ease;
   }

   .font-picker-row:hover {
     background: #f5f5f5;
   }

   .font-picker-row.selected {
     background: #e8f4ff;
   }

   .font-name {
     font-size: 15px;
     flex: 1;
   }

   .font-meta {
     display: flex;
     align-items: center;
     gap: 8px;
   }

   .font-badge {
     font-size: 10px;
     padding: 2px 6px;
     border-radius: 4px;
     background: #e0e0e0;
   }

   .font-badge.recent {
     background: #d4edda;
     color: #155724;
   }

   .font-category {
     font-size: 11px;
     color: #888;
     text-transform: capitalize;
   }
   ```

4. Create `src/components/pickers/index.ts`:
   ```typescript
   export { FontPicker } from './FontPicker';
   export { FontPickerList } from './FontPickerList';
   ```
  </action>
  <verify>
    TypeScript compiles: `npx tsc --noEmit`
    Render FontPicker in App.tsx with test props
    Verify search filters fonts, category buttons work
    Verify virtualized list scrolls smoothly with 60+ fonts
    Verify hover loads font and shows in font-family
  </verify>
  <done>
    FontPicker with search (TYPE-03), category filters (TYPE-04), popular fonts (TYPE-05), recently used (TYPE-06), font names in own typeface (TYPE-07), hover preview via useHoverPreview (TYPE-08), virtualized with react-window
  </done>
</task>

</tasks>

<verification>
1. TYPE-03: Font picker opens with search-as-you-type (Fuse.js fuzzy search)
2. TYPE-04: Category filters (sans, serif, display, mono) work
3. TYPE-05: Popular fonts (~20) shown by default when no search/filter
4. TYPE-06: Recently used fonts pinned to top of list
5. TYPE-07: Font names render in their own typeface (loaded on hover)
6. Font preview appears within 2 seconds of hover (3s timeout with fallback)
7. System fallback shown when font not yet loaded or fails to load
</verification>

<success_criteria>
- Font picker renders with search input and category filters
- Search is fuzzy (typo-tolerant)
- List virtualized (react-window), smooth scrolling with 60+ fonts
- Hover triggers font load and preview
- Click calls onSelect, hover calls onPreviewChange
- Recent fonts appear at top of list
</success_criteria>

<output>
After completion, create `.planning/phases/03-logo-typography-tiles/03-03-SUMMARY.md`
</output>
