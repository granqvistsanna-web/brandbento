---
phase: 06-workflows
plan: 04
type: execute
wave: 3
depends_on: ["06-03"]
files_modified:
  - src/hooks/useReadOnly.ts
  - src/App.tsx
  - src/components/BentoCanvas.jsx
  - src/index.css
autonomous: true

must_haves:
  truths:
    - "Shared link opens in read-only mode"
    - "Read-only view has no edit panels"
    - "Read-only view has no hover states"
    - "Read-only view shows a banner indicating view-only mode"
  artifacts:
    - path: "src/hooks/useReadOnly.ts"
      provides: "Read-only mode detection from URL"
      exports: ["useReadOnly", "ReadOnlyProvider"]
  key_links:
    - from: "src/hooks/useReadOnly.ts"
      to: "URL searchParams"
      via: "view=readonly detection"
      pattern: "searchParams.*get.*view"
    - from: "src/App.tsx"
      to: "src/hooks/useReadOnly.ts"
      via: "ReadOnlyProvider wrapper"
      pattern: "ReadOnlyProvider"
---

<objective>
Implement read-only view mode for shared links with disabled interactions.

Purpose: Allow users to share their moodboard for viewing without accidental edits.

Output: Shared links open in a view-only mode with no edit capabilities and a subtle indicator.
</objective>

<execution_context>
@/Users/sannagranqvist/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sannagranqvist/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-workflows/06-RESEARCH.md
@src/utils/sharing.ts

Key requirements:
- SHAR-03: Shared link opens read-only view (no edit panels, no hover states)

The sharing utility adds ?view=readonly to shared URLs. This plan detects that parameter and disables interactions.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create read-only detection hook and context</name>
  <files>src/hooks/useReadOnly.ts</files>
  <action>
Create a hook and context for read-only mode detection:

```typescript
import { createContext, useContext, ReactNode, useMemo } from 'react';

// Context for read-only state
const ReadOnlyContext = createContext<boolean>(false);

interface ReadOnlyProviderProps {
  children: ReactNode;
}

/**
 * Provider that detects read-only mode from URL and provides it to children
 */
export function ReadOnlyProvider({ children }: ReadOnlyProviderProps) {
  const isReadOnly = useMemo(() => {
    if (typeof window === 'undefined') return false;
    const params = new URLSearchParams(window.location.search);
    return params.get('view') === 'readonly';
  }, []);

  return (
    <ReadOnlyContext.Provider value={isReadOnly}>
      {children}
    </ReadOnlyContext.Provider>
  );
}

/**
 * Hook to check if app is in read-only mode
 */
export function useReadOnly(): boolean {
  return useContext(ReadOnlyContext);
}

/**
 * Utility to check read-only directly (for non-hook contexts)
 */
export function isReadOnlyMode(): boolean {
  if (typeof window === 'undefined') return false;
  const params = new URLSearchParams(window.location.search);
  return params.get('view') === 'readonly';
}
```

This provides:
1. ReadOnlyProvider - wraps app and detects ?view=readonly
2. useReadOnly hook - for components to check read-only state
3. isReadOnlyMode function - for non-hook contexts
  </action>
  <verify>File exists with all three exports</verify>
  <done>Read-only detection hook and context created</done>
</task>

<task type="auto">
  <name>Task 2: Add read-only CSS styles</name>
  <files>src/index.css</files>
  <action>
Add CSS classes for read-only mode at the end of the file:

```css
/* ===== READ-ONLY MODE ===== */
.read-only-mode {
  /* Disable all pointer events on tiles */
}

.read-only-mode .bento-tile {
  pointer-events: none;
  cursor: default;
}

.read-only-mode .bento-tile:hover {
  /* Remove hover effects */
  transform: none !important;
  box-shadow: none !important;
}

/* Hide edit-related UI */
.read-only-mode .edit-panel,
.read-only-mode .edit-button,
.read-only-mode .hover-overlay,
.read-only-mode .control-panel,
.read-only-mode [data-editable] {
  display: none !important;
}

/* Read-only banner */
.read-only-banner {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  z-index: 100;
  padding: 8px 16px;
  background: var(--accent);
  color: white;
  text-align: center;
  font-size: 13px;
  font-weight: 500;
}

.read-only-banner a {
  color: white;
  text-decoration: underline;
  margin-left: 8px;
}
```

These styles:
- Disable pointer events on tiles
- Remove hover transforms
- Hide edit panels and controls
- Style the read-only indicator banner
  </action>
  <verify>CSS classes defined in index.css</verify>
  <done>Read-only CSS styles added</done>
</task>

<task type="auto">
  <name>Task 3: Wire read-only mode in App.tsx</name>
  <files>src/App.tsx</files>
  <action>
Wrap app with ReadOnlyProvider and conditionally render based on mode:

1. Add imports:
```typescript
import { ReadOnlyProvider, useReadOnly } from './hooks/useReadOnly';
```

2. Create a new inner component that uses the hook:
```typescript
function AppContent() {
  useTheme();
  useKeyboardShortcuts();

  const isReadOnly = useReadOnly();
  const { undo, redo, history, loadRandomTemplate, brand, tiles } = useBrandStore();

  // ... all the existing handlers ...

  return (
    <div className={`h-screen flex flex-col overflow-hidden ${isReadOnly ? 'read-only-mode' : ''}`}>
      {/* Read-only banner */}
      {isReadOnly && (
        <div className="read-only-banner">
          View-only mode
          <a href={window.location.pathname}>Create your own</a>
        </div>
      )}

      {/* Don't render header toolbar in read-only mode */}
      {!isReadOnly && (
        <header data-export-exclude="true" className="...">
          {/* existing header content */}
        </header>
      )}

      {/* Main content - always render */}
      <main className={`flex-1 flex overflow-hidden ${isReadOnly ? 'pt-0' : ''}`}>
        {/* Hide control panel in read-only */}
        {!isReadOnly && (
          <div data-export-exclude="true">
            <ControlPanel />
          </div>
        )}

        <div ref={canvasRef} className="flex-1 overflow-auto">
          <BentoCanvas />
        </div>
      </main>

      {/* Hide footer in read-only */}
      {!isReadOnly && (
        <footer data-export-exclude="true" className="...">
          {/* existing footer content */}
        </footer>
      )}

      {!isReadOnly && <Toaster ... />}
    </div>
  );
}
```

3. Wrap the export with ReadOnlyProvider:
```typescript
export default function App() {
  return (
    <ReadOnlyProvider>
      <AppContent />
    </ReadOnlyProvider>
  );
}
```

This approach:
- Detects read-only mode from URL
- Hides toolbar, control panel, and footer
- Shows a banner with "Create your own" link
- Applies read-only-mode class to disable interactions
  </action>
  <verify>Open a shared URL with ?view=readonly - see only the canvas with banner</verify>
  <done>Read-only mode wired with conditional rendering</done>
</task>

</tasks>

<verification>
1. Open normal URL (no ?view=readonly) - full UI with editing
2. Open URL with ?view=readonly - only canvas visible with banner
3. In read-only mode, clicking tiles does nothing
4. In read-only mode, no hover effects on tiles
5. "Create your own" link navigates to editable version
6. Export a shared link from Plan 03 - opens in read-only mode
</verification>

<success_criteria>
- [ ] ?view=readonly parameter is detected
- [ ] Read-only mode hides toolbar and control panel
- [ ] Read-only mode shows view-only banner
- [ ] Tiles are not interactive in read-only mode
- [ ] "Create your own" link works
- [ ] Normal URLs still work with full editing
</success_criteria>

<output>
After completion, create `.planning/phases/06-workflows/06-04-SUMMARY.md`
</output>
