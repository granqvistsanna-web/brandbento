---
phase: 01-foundation-extraction
plan: 03
type: execute
wave: 2
depends_on: [01, 02]
files_modified:
  - src/services/corsProxy.ts
  - src/services/extractColors.ts
  - src/services/extractFonts.ts
  - src/services/extractLogo.ts
  - src/services/extractImages.ts
  - src/services/brandExtractor.ts
autonomous: true

must_haves:
  truths:
    - "Color extraction returns 5-10 colors from CSS custom properties or semantic elements"
    - "Font extraction waits for document.fonts.ready before reading font families"
    - "Logo extraction tries favicon hierarchy before falling back to monogram"
    - "Image extraction finds hero images or OG images"
    - "Extraction orchestrator populates fallbacks immediately, then updates as extraction completes"
    - "Each extraction stage failure uses fallback values without blocking other stages"
  artifacts:
    - path: "src/services/brandExtractor.ts"
      provides: "Main extraction orchestrator"
      exports: ["extractBrand"]
      min_lines: 80
    - path: "src/services/extractColors.ts"
      provides: "Color palette extraction from CSS"
      exports: ["extractColors"]
    - path: "src/services/extractFonts.ts"
      provides: "Typography extraction with font loading wait"
      exports: ["extractFonts"]
    - path: "src/services/extractLogo.ts"
      provides: "Logo extraction with favicon fallback hierarchy"
      exports: ["extractLogo"]
    - path: "src/services/extractImages.ts"
      provides: "Hero and OG image extraction"
      exports: ["extractImages"]
  key_links:
    - from: "src/services/brandExtractor.ts"
      to: "src/services/corsProxy.ts"
      via: "fetch HTML through proxy"
      pattern: "fetchViaProxy"
    - from: "src/services/brandExtractor.ts"
      to: "src/state/defaults.ts"
      via: "fallback values"
      pattern: "DEFAULT_ASSETS"
---

<objective>
Create brand extraction services that parse HTML/CSS to extract colors, fonts, logo, and images from any website.

Purpose: Enable users to enter a URL and automatically populate the canvas with that site's brand assets. Extraction must be fault-tolerant with fallbacks for every asset type.

Output: Five extraction service modules plus an orchestrator that coordinates progressive extraction with fallbacks.
</objective>

<execution_context>
@/Users/sannagranqvist/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sannagranqvist/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-extraction/01-RESEARCH.md
@.planning/phases/01-foundation-extraction/01-02-SUMMARY.md (if exists)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CORS proxy client and color/font extractors</name>
  <files>src/services/corsProxy.ts, src/services/extractColors.ts, src/services/extractFonts.ts</files>
  <action>
Create `src/services/corsProxy.ts`:
```typescript
const CORS_PROXY_URL = import.meta.env.VITE_CORS_PROXY_URL || 'http://localhost:8787';

export async function fetchViaProxy(url: string, timeout = 5000): Promise<string> {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeout);

  try {
    const proxyUrl = `${CORS_PROXY_URL}?url=${encodeURIComponent(url)}`;
    const response = await fetch(proxyUrl, { signal: controller.signal });
    clearTimeout(timeoutId);

    if (!response.ok) {
      if (response.status === 429) {
        throw new Error('Rate limit exceeded. Please wait a minute and try again.');
      }
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    return await response.text();
  } catch (error) {
    clearTimeout(timeoutId);
    if ((error as Error).name === 'AbortError') {
      throw new Error('Request timed out');
    }
    throw error;
  }
}
```

Create `src/services/extractColors.ts`:
```typescript
interface ExtractedColors {
  colors: string[];
  source: 'css-vars' | 'semantic' | 'stylesheet';
}

export async function extractColors(doc: Document): Promise<ExtractedColors> {
  const colors = new Set<string>();

  // Strategy 1: CSS custom properties (highest confidence)
  const cssVarColors = extractFromCSSVariables(doc);
  cssVarColors.forEach(c => colors.add(c));

  if (colors.size >= 5) {
    return { colors: Array.from(colors).slice(0, 10), source: 'css-vars' };
  }

  // Strategy 2: Semantic elements (buttons, links, headings)
  const semanticColors = extractFromSemanticElements(doc);
  semanticColors.forEach(c => colors.add(c));

  if (colors.size >= 5) {
    return { colors: Array.from(colors).slice(0, 10), source: 'semantic' };
  }

  // Strategy 3: Stylesheets
  const stylesheetColors = extractFromStylesheets(doc);
  stylesheetColors.forEach(c => colors.add(c));

  if (colors.size >= 3) {
    return { colors: Array.from(colors).slice(0, 10), source: 'stylesheet' };
  }

  throw new Error('Insufficient colors extracted');
}

function extractFromCSSVariables(doc: Document): string[] {
  const colors: string[] = [];

  try {
    Array.from(doc.styleSheets).forEach(sheet => {
      try {
        Array.from(sheet.cssRules).forEach(rule => {
          if (rule instanceof CSSStyleRule) {
            const style = rule.style;
            for (let i = 0; i < style.length; i++) {
              const prop = style[i];
              if (prop.startsWith('--') &&
                  (prop.includes('color') || prop.includes('bg') || prop.includes('primary') || prop.includes('accent'))) {
                const value = style.getPropertyValue(prop).trim();
                const hex = cssValueToHex(value);
                if (hex && !isNearNeutral(hex)) {
                  colors.push(hex);
                }
              }
            }
          }
        });
      } catch (e) {
        // Cross-origin stylesheet, skip
      }
    });
  } catch (e) {
    // No stylesheets accessible
  }

  return colors;
}

function extractFromSemanticElements(doc: Document): string[] {
  const colors: string[] = [];
  const selectors = 'button, a, h1, h2, h3, .btn, .cta, [role="button"], .primary, .accent';

  doc.querySelectorAll(selectors).forEach(el => {
    try {
      const computed = window.getComputedStyle(el);
      [computed.color, computed.backgroundColor, computed.borderColor].forEach(color => {
        const hex = rgbToHex(color);
        if (hex && !isNearNeutral(hex)) {
          colors.push(hex);
        }
      });
    } catch (e) {
      // Element not accessible
    }
  });

  return colors;
}

function extractFromStylesheets(doc: Document): string[] {
  const colors: string[] = [];
  const colorRegex = /#[0-9A-Fa-f]{3,8}\b|rgb\([^)]+\)|hsl\([^)]+\)/g;

  try {
    Array.from(doc.styleSheets).forEach(sheet => {
      try {
        Array.from(sheet.cssRules).forEach(rule => {
          if (rule instanceof CSSStyleRule) {
            const matches = rule.cssText.match(colorRegex) || [];
            matches.forEach(match => {
              const hex = cssValueToHex(match);
              if (hex && !isNearNeutral(hex)) {
                colors.push(hex);
              }
            });
          }
        });
      } catch (e) {
        // Cross-origin
      }
    });
  } catch (e) {
    // No access
  }

  return colors;
}

function cssValueToHex(value: string): string | null {
  value = value.trim().toLowerCase();

  // Already hex
  if (value.startsWith('#')) {
    if (value.length === 4) {
      // #RGB -> #RRGGBB
      return '#' + value[1] + value[1] + value[2] + value[2] + value[3] + value[3];
    }
    if (value.length === 7 || value.length === 9) {
      return value.slice(0, 7); // Drop alpha if present
    }
    return null;
  }

  // RGB/RGBA
  const rgbMatch = value.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)/);
  if (rgbMatch) {
    const [, r, g, b] = rgbMatch;
    return rgbToHexValue(parseInt(r), parseInt(g), parseInt(b));
  }

  return null;
}

function rgbToHex(rgb: string): string | null {
  if (!rgb || rgb === 'transparent' || rgb === 'inherit') return null;
  return cssValueToHex(rgb);
}

function rgbToHexValue(r: number, g: number, b: number): string {
  const toHex = (n: number) => n.toString(16).padStart(2, '0');
  return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
}

function isNearNeutral(hex: string): boolean {
  // Check if color is grayscale or near-white/near-black
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);

  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const diff = max - min;

  // Low saturation = neutral
  if (diff < 20) return true;

  // Near white or black
  const avg = (r + g + b) / 3;
  if (avg > 240 || avg < 15) return true;

  return false;
}
```

Create `src/services/extractFonts.ts`:
```typescript
interface ExtractedFonts {
  primaryFont: string;
  secondaryFont: string;
  source: 'google-fonts' | 'css-vars' | 'document-fonts' | 'font-face';
}

const SYSTEM_FONTS = [
  'Arial', 'Helvetica', 'Times New Roman', 'Times', 'Courier New', 'Courier',
  'Verdana', 'Georgia', 'Palatino', 'Garamond', 'Comic Sans MS', 'Impact',
  'system-ui', '-apple-system', 'BlinkMacSystemFont', 'Segoe UI', 'Roboto',
  'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'sans-serif',
  'serif', 'monospace', 'cursive', 'fantasy'
];

export async function extractFonts(doc: Document): Promise<ExtractedFonts> {
  // Strategy 1: Google Fonts link tags (highest confidence)
  const googleFonts = extractFromGoogleFontsLink(doc);
  if (googleFonts) return googleFonts;

  // Strategy 2: CSS custom properties
  const cssVarFonts = extractFromCSSVariables(doc);
  if (cssVarFonts) return cssVarFonts;

  // Strategy 3: Wait for fonts to load, check document.fonts
  // Wait up to 3 seconds for fonts
  await Promise.race([
    document.fonts.ready,
    new Promise(resolve => setTimeout(resolve, 3000))
  ]);

  const loadedFonts = extractFromDocumentFonts();
  if (loadedFonts) return loadedFonts;

  // Strategy 4: Parse @font-face declarations
  const fontFaceFonts = extractFromFontFace(doc);
  if (fontFaceFonts) return fontFaceFonts;

  throw new Error('No web fonts detected');
}

function extractFromGoogleFontsLink(doc: Document): ExtractedFonts | null {
  const link = doc.querySelector('link[href*="fonts.googleapis.com"]');
  if (!link) return null;

  const href = link.getAttribute('href');
  if (!href) return null;

  // Parse family=Font+Name:wght@400;700 format
  const familyMatch = href.match(/family=([^&]+)/);
  if (!familyMatch) return null;

  const families = familyMatch[1]
    .split('|')
    .map(f => f.split(':')[0].replace(/\+/g, ' '))
    .filter(f => f.length > 0);

  if (families.length >= 2) {
    return {
      primaryFont: families[0],
      secondaryFont: families[1],
      source: 'google-fonts'
    };
  }

  if (families.length === 1) {
    return {
      primaryFont: families[0],
      secondaryFont: families[0], // Same font for both
      source: 'google-fonts'
    };
  }

  return null;
}

function extractFromCSSVariables(doc: Document): ExtractedFonts | null {
  const fontVars: string[] = [];

  try {
    Array.from(doc.styleSheets).forEach(sheet => {
      try {
        Array.from(sheet.cssRules).forEach(rule => {
          if (rule instanceof CSSStyleRule) {
            const style = rule.style;
            for (let i = 0; i < style.length; i++) {
              const prop = style[i];
              if (prop.startsWith('--') && prop.includes('font') && prop.includes('family')) {
                const value = style.getPropertyValue(prop).trim();
                const family = cleanFontFamily(value);
                if (family && !isSystemFont(family)) {
                  fontVars.push(family);
                }
              }
            }
          }
        });
      } catch (e) {
        // Cross-origin
      }
    });
  } catch (e) {
    // No access
  }

  if (fontVars.length >= 2) {
    return {
      primaryFont: fontVars[0],
      secondaryFont: fontVars[1],
      source: 'css-vars'
    };
  }

  if (fontVars.length === 1) {
    return {
      primaryFont: fontVars[0],
      secondaryFont: fontVars[0],
      source: 'css-vars'
    };
  }

  return null;
}

function extractFromDocumentFonts(): ExtractedFonts | null {
  const fonts = Array.from(document.fonts)
    .map(font => font.family.replace(/['"]/g, ''))
    .filter(family => !isSystemFont(family));

  // Dedupe
  const unique = [...new Set(fonts)];

  if (unique.length >= 2) {
    return {
      primaryFont: unique[0],
      secondaryFont: unique[1],
      source: 'document-fonts'
    };
  }

  if (unique.length === 1) {
    return {
      primaryFont: unique[0],
      secondaryFont: unique[0],
      source: 'document-fonts'
    };
  }

  return null;
}

function extractFromFontFace(doc: Document): ExtractedFonts | null {
  const fontFamilies: string[] = [];

  try {
    Array.from(doc.styleSheets).forEach(sheet => {
      try {
        Array.from(sheet.cssRules).forEach(rule => {
          if (rule instanceof CSSFontFaceRule) {
            const family = rule.style.getPropertyValue('font-family');
            const cleaned = cleanFontFamily(family);
            if (cleaned && !isSystemFont(cleaned)) {
              fontFamilies.push(cleaned);
            }
          }
        });
      } catch (e) {
        // Cross-origin
      }
    });
  } catch (e) {
    // No access
  }

  const unique = [...new Set(fontFamilies)];

  if (unique.length >= 2) {
    return {
      primaryFont: unique[0],
      secondaryFont: unique[1],
      source: 'font-face'
    };
  }

  if (unique.length === 1) {
    return {
      primaryFont: unique[0],
      secondaryFont: unique[0],
      source: 'font-face'
    };
  }

  return null;
}

function cleanFontFamily(value: string): string {
  return value.split(',')[0].replace(/['"]/g, '').trim();
}

function isSystemFont(family: string): boolean {
  const normalized = family.toLowerCase();
  return SYSTEM_FONTS.some(sys => normalized.includes(sys.toLowerCase()));
}
```
  </action>
  <verify>
Files exist: `src/services/corsProxy.ts`, `src/services/extractColors.ts`, `src/services/extractFonts.ts`.
No TypeScript errors.
  </verify>
  <done>
CORS proxy client and color/font extraction services created with multi-strategy approach.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create logo and image extractors</name>
  <files>src/services/extractLogo.ts, src/services/extractImages.ts</files>
  <action>
Create `src/services/extractLogo.ts`:
```typescript
interface ExtractedLogo {
  logo: string;
  source: 'favicon-svg' | 'favicon-png' | 'apple-touch-icon' | 'favicon-default' | 'header-img';
}

export async function extractLogo(doc: Document, baseUrl: string): Promise<ExtractedLogo> {
  // Strategy 1: SVG favicon (highest quality)
  const svgIcon = doc.querySelector('link[rel*="icon"][type="image/svg+xml"]');
  if (svgIcon) {
    const href = svgIcon.getAttribute('href');
    if (href) {
      return { logo: resolveUrl(href, baseUrl), source: 'favicon-svg' };
    }
  }

  // Strategy 2: PNG favicon with size preference
  const pngIcons = doc.querySelectorAll('link[rel*="icon"][type="image/png"]');
  if (pngIcons.length > 0) {
    // Prefer largest icon
    let bestIcon: Element | null = null;
    let bestSize = 0;

    pngIcons.forEach(icon => {
      const sizes = icon.getAttribute('sizes');
      if (sizes) {
        const size = parseInt(sizes.split('x')[0]) || 0;
        if (size > bestSize) {
          bestSize = size;
          bestIcon = icon;
        }
      } else if (!bestIcon) {
        bestIcon = icon;
      }
    });

    const href = bestIcon?.getAttribute('href');
    if (href) {
      return { logo: resolveUrl(href, baseUrl), source: 'favicon-png' };
    }
  }

  // Strategy 3: Apple touch icon (180x180, good quality)
  const appleIcon = doc.querySelector('link[rel="apple-touch-icon"], link[rel="apple-touch-icon-precomposed"]');
  if (appleIcon) {
    const href = appleIcon.getAttribute('href');
    if (href) {
      return { logo: resolveUrl(href, baseUrl), source: 'apple-touch-icon' };
    }
  }

  // Strategy 4: Generic favicon link
  const genericIcon = doc.querySelector('link[rel="icon"], link[rel="shortcut icon"]');
  if (genericIcon) {
    const href = genericIcon.getAttribute('href');
    if (href) {
      return { logo: resolveUrl(href, baseUrl), source: 'favicon-default' };
    }
  }

  // Strategy 5: Check header/nav for logo image
  const logoSelectors = [
    'header img[class*="logo"]',
    'nav img[class*="logo"]',
    'header a img',
    '.logo img',
    '#logo img',
    'img.logo',
    '[aria-label*="logo"] img',
  ];

  for (const selector of logoSelectors) {
    const img = doc.querySelector(selector);
    if (img) {
      const src = img.getAttribute('src');
      if (src) {
        return { logo: resolveUrl(src, baseUrl), source: 'header-img' };
      }
    }
  }

  // Strategy 6: Default /favicon.ico (we'll verify it exists via fetch)
  const defaultFavicon = resolveUrl('/favicon.ico', baseUrl);

  // Note: We can't verify the favicon exists without a fetch,
  // but we'll return it as a candidate. The caller should handle 404s.
  return { logo: defaultFavicon, source: 'favicon-default' };
}

function resolveUrl(href: string, baseUrl: string): string {
  if (href.startsWith('data:') || href.startsWith('http://') || href.startsWith('https://')) {
    return href;
  }

  try {
    return new URL(href, baseUrl).href;
  } catch {
    return href;
  }
}
```

Create `src/services/extractImages.ts`:
```typescript
interface ExtractedImages {
  heroImage: string | null;
  source: 'og-image' | 'hero-section' | 'large-image' | null;
}

export async function extractImages(doc: Document, baseUrl: string): Promise<ExtractedImages> {
  // Strategy 1: Open Graph image (most reliable for brand imagery)
  const ogImage = doc.querySelector('meta[property="og:image"]');
  if (ogImage) {
    const content = ogImage.getAttribute('content');
    if (content) {
      return { heroImage: resolveUrl(content, baseUrl), source: 'og-image' };
    }
  }

  // Strategy 2: Twitter card image
  const twitterImage = doc.querySelector('meta[name="twitter:image"]');
  if (twitterImage) {
    const content = twitterImage.getAttribute('content');
    if (content) {
      return { heroImage: resolveUrl(content, baseUrl), source: 'og-image' };
    }
  }

  // Strategy 3: Hero section image
  const heroSelectors = [
    '.hero img',
    '#hero img',
    '[class*="hero"] img',
    'section:first-of-type img',
    'header + section img',
    'main > section:first-child img',
  ];

  for (const selector of heroSelectors) {
    const img = doc.querySelector(selector);
    if (img) {
      const src = img.getAttribute('src') || img.getAttribute('data-src');
      if (src && !isSmallOrIcon(img)) {
        return { heroImage: resolveUrl(src, baseUrl), source: 'hero-section' };
      }
    }
  }

  // Strategy 4: First large image on page
  const allImages = doc.querySelectorAll('img');
  for (const img of allImages) {
    const src = img.getAttribute('src') || img.getAttribute('data-src');
    if (!src) continue;

    // Skip small images, icons, logos, tracking pixels
    if (isSmallOrIcon(img)) continue;

    // Skip images that look like logos
    const alt = (img.getAttribute('alt') || '').toLowerCase();
    const className = (img.className || '').toLowerCase();
    if (alt.includes('logo') || className.includes('logo') || className.includes('icon')) {
      continue;
    }

    return { heroImage: resolveUrl(src, baseUrl), source: 'large-image' };
  }

  // No suitable image found
  return { heroImage: null, source: null };
}

function isSmallOrIcon(img: Element): boolean {
  const width = img.getAttribute('width');
  const height = img.getAttribute('height');

  if (width && parseInt(width) < 100) return true;
  if (height && parseInt(height) < 100) return true;

  // Check for common icon patterns in src
  const src = img.getAttribute('src') || '';
  if (src.includes('icon') || src.includes('favicon') || src.includes('logo')) {
    return true;
  }

  // Check for SVG icons
  if (src.endsWith('.svg') && !src.includes('hero') && !src.includes('banner')) {
    return true;
  }

  return false;
}

function resolveUrl(href: string, baseUrl: string): string {
  if (href.startsWith('data:') || href.startsWith('http://') || href.startsWith('https://')) {
    return href;
  }

  try {
    return new URL(href, baseUrl).href;
  } catch {
    return href;
  }
}
```
  </action>
  <verify>
Files exist: `src/services/extractLogo.ts`, `src/services/extractImages.ts`.
No TypeScript errors.
  </verify>
  <done>
Logo and image extraction services created with multi-strategy fallback hierarchy.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create brand extraction orchestrator</name>
  <files>src/services/brandExtractor.ts</files>
  <action>
Create `src/services/brandExtractor.ts`:
```typescript
import type { BrandAssets, ExtractionStage } from '@/types/brand';
import { DEFAULT_ASSETS, generateMonogram } from '@/state/defaults';
import { fetchViaProxy } from './corsProxy';
import { extractColors } from './extractColors';
import { extractFonts } from './extractFonts';
import { extractLogo } from './extractLogo';
import { extractImages } from './extractImages';

export interface ExtractionProgress {
  stage: ExtractionStage;
  assets: Partial<BrandAssets>;
  error?: string;
}

export type ProgressCallback = (progress: ExtractionProgress) => void;

export async function extractBrand(
  url: string,
  onProgress?: ProgressCallback
): Promise<BrandAssets> {
  // Normalize URL
  if (!url.startsWith('http://') && !url.startsWith('https://')) {
    url = 'https://' + url;
  }

  // Start with defaults immediately
  const assets: BrandAssets = {
    ...DEFAULT_ASSETS,
    logo: generateMonogram(url),
    logoSource: 'default',
  };

  onProgress?.({ stage: 'fetching', assets });

  let doc: Document;
  let html: string;

  try {
    // Fetch HTML via CORS proxy
    html = await fetchViaProxy(url);
    doc = new DOMParser().parseFromString(html, 'text/html');

    // Set base URL for relative URLs
    const base = doc.createElement('base');
    base.href = url;
    doc.head.prepend(base);

  } catch (error) {
    const message = error instanceof Error ? error.message : 'Failed to fetch page';
    onProgress?.({ stage: 'error', assets, error: message });
    return assets; // Return defaults on fetch failure
  }

  // Extract colors
  onProgress?.({ stage: 'colors', assets });
  try {
    const colorResult = await extractColors(doc);
    assets.colors = colorResult.colors;
    assets.colorsSource = 'extracted';
    onProgress?.({ stage: 'colors', assets });
  } catch (error) {
    console.warn('Color extraction failed:', error);
    // Keep defaults
  }

  // Extract fonts
  onProgress?.({ stage: 'fonts', assets });
  try {
    const fontResult = await extractFonts(doc);
    assets.primaryFont = fontResult.primaryFont;
    assets.secondaryFont = fontResult.secondaryFont;
    assets.fontsSource = 'extracted';
    onProgress?.({ stage: 'fonts', assets });
  } catch (error) {
    console.warn('Font extraction failed:', error);
    // Keep defaults
  }

  // Extract images
  onProgress?.({ stage: 'images', assets });
  try {
    const imageResult = await extractImages(doc, url);
    if (imageResult.heroImage) {
      assets.heroImage = imageResult.heroImage;
      assets.imagesSource = 'extracted';
    }
    onProgress?.({ stage: 'images', assets });
  } catch (error) {
    console.warn('Image extraction failed:', error);
    // Keep defaults (null heroImage)
  }

  // Extract logo
  onProgress?.({ stage: 'logo', assets });
  try {
    const logoResult = await extractLogo(doc, url);
    assets.logo = logoResult.logo;
    assets.logoSource = logoResult.source;
    onProgress?.({ stage: 'logo', assets });
  } catch (error) {
    console.warn('Logo extraction failed:', error);
    // Keep monogram fallback
  }

  // Complete
  onProgress?.({ stage: 'complete', assets });

  return assets;
}

// Helper to check if an asset is using defaults
export function isDefaultAsset(assets: BrandAssets, assetType: keyof BrandAssets): boolean {
  switch (assetType) {
    case 'colors':
      return assets.colorsSource === 'default';
    case 'primaryFont':
    case 'secondaryFont':
      return assets.fontsSource === 'default';
    case 'logo':
      return assets.logoSource === 'default';
    case 'heroImage':
      return assets.imagesSource === 'default';
    default:
      return false;
  }
}
```

Add export barrel file `src/services/index.ts`:
```typescript
export { extractBrand, isDefaultAsset } from './brandExtractor';
export type { ExtractionProgress, ProgressCallback } from './brandExtractor';
export { fetchViaProxy } from './corsProxy';
export { extractColors } from './extractColors';
export { extractFonts } from './extractFonts';
export { extractLogo } from './extractLogo';
export { extractImages } from './extractImages';
```
  </action>
  <verify>
File exists: `src/services/brandExtractor.ts`, `src/services/index.ts`.
`npm run build` succeeds without TypeScript errors.
  </verify>
  <done>
Brand extraction orchestrator coordinates progressive extraction with fallbacks for all asset types.
  </done>
</task>

</tasks>

<verification>
1. All extraction service files exist in `src/services/`
2. `npm run build` completes without TypeScript errors
3. Services handle extraction failures gracefully (no thrown exceptions reach caller)
4. Each extractor has multiple fallback strategies
5. Orchestrator populates defaults immediately before attempting extraction
</verification>

<success_criteria>
- Color extraction parses CSS custom properties and semantic elements
- Font extraction waits for document.fonts.ready
- Logo extraction tries favicon hierarchy (SVG > PNG > Apple > default)
- Image extraction finds OG images and hero section images
- Orchestrator coordinates all extractors with progressive updates
- All failures gracefully fall back to defaults
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-extraction/01-03-SUMMARY.md`
</output>
