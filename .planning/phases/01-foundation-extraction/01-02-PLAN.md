---
phase: 01-foundation-extraction
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - vite.config.ts
  - tsconfig.json
  - index.html
  - src/main.tsx
  - src/App.tsx
  - src/state/canvasState.ts
  - src/state/persistence.ts
  - src/state/defaults.ts
  - src/utils/compression.ts
  - src/types/brand.ts
autonomous: true

must_haves:
  truths:
    - "React app runs in browser via npm run dev"
    - "Canvas state persists to localStorage on every change"
    - "Canvas state loads from URL hash when present"
    - "Canvas state loads from localStorage when no URL hash"
    - "Compressed URL state stays under 2000 characters for typical canvas"
  artifacts:
    - path: "src/state/canvasState.ts"
      provides: "Zustand store for canvas state"
      min_lines: 40
    - path: "src/state/persistence.ts"
      provides: "URL and localStorage sync"
      exports: ["persistState", "loadState", "syncStateToURL"]
    - path: "src/utils/compression.ts"
      provides: "lz-string compression utilities"
      exports: ["compressState", "decompressState"]
    - path: "src/types/brand.ts"
      provides: "TypeScript types for brand assets"
      contains: "BrandAssets"
  key_links:
    - from: "src/state/canvasState.ts"
      to: "src/state/persistence.ts"
      via: "subscribe to persist on change"
      pattern: "subscribe.*persistState"
    - from: "src/state/persistence.ts"
      to: "src/utils/compression.ts"
      via: "compress for URL"
      pattern: "import.*compression"
---

<objective>
Set up React + Vite application foundation with state management and dual persistence (localStorage + URL hash).

Purpose: Canvas state must persist automatically and be shareable via URL. This establishes the data layer that all tiles and extraction will use.

Output: Running React app with Zustand store, localStorage auto-save, and lz-string URL compression.
</objective>

<execution_context>
@/Users/sannagranqvist/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sannagranqvist/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-extraction/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize React + Vite + TypeScript project</name>
  <files>package.json, vite.config.ts, tsconfig.json, index.html, src/main.tsx, src/App.tsx</files>
  <action>
Initialize the project using Vite with React and TypeScript:

```bash
npm create vite@latest . -- --template react-ts
```

If prompted about existing files, choose to overwrite (the project is empty except for .planning/).

Install dependencies:
```bash
npm install
npm install zustand lz-string react-loading-skeleton nanoid
npm install -D @types/lz-string
```

Update `vite.config.ts` to use absolute imports:
```typescript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
})
```

Update `tsconfig.json` to add path alias:
```json
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  }
}
```

Create minimal `src/App.tsx`:
```tsx
function App() {
  return (
    <div className="app">
      <h1>Brand Bento</h1>
      <p>Foundation loading...</p>
    </div>
  )
}

export default App
```

Verify app runs with `npm run dev`.
  </action>
  <verify>
`npm run dev` starts Vite dev server.
Browser at localhost:5173 shows "Brand Bento" heading.
  </verify>
  <done>
React + Vite + TypeScript project initialized and running.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create brand types and default values</name>
  <files>src/types/brand.ts, src/state/defaults.ts</files>
  <action>
Create `src/types/brand.ts`:
```typescript
export interface BrandAssets {
  // Colors
  colors: string[];
  colorsSource: 'extracted' | 'default';

  // Typography
  primaryFont: string;
  secondaryFont: string;
  fontsSource: 'extracted' | 'default';

  // Logo
  logo: string | null;  // URL or data URI
  logoSource: 'favicon-svg' | 'favicon-png' | 'apple-touch-icon' | 'favicon-default' | 'header-img' | 'default';

  // Imagery
  heroImage: string | null;  // URL or data URI
  imagesSource: 'extracted' | 'default';
}

export interface CanvasState {
  version: number;
  sourceUrl: string | null;
  assets: BrandAssets;
  extractedAt: number | null;
  lastModified: number;
}

export type ExtractionStage = 'idle' | 'fetching' | 'colors' | 'fonts' | 'images' | 'logo' | 'complete' | 'error';
```

Create `src/state/defaults.ts`:
```typescript
import type { BrandAssets, CanvasState } from '@/types/brand';

export const DEFAULT_COLORS = ['#111111', '#555555', '#F5F5F5', '#2563EB', '#FFFFFF'];
export const DEFAULT_PRIMARY_FONT = 'Inter';
export const DEFAULT_SECONDARY_FONT = 'Lora';

export const DEFAULT_ASSETS: BrandAssets = {
  colors: DEFAULT_COLORS,
  colorsSource: 'default',
  primaryFont: DEFAULT_PRIMARY_FONT,
  secondaryFont: DEFAULT_SECONDARY_FONT,
  fontsSource: 'default',
  logo: null,
  logoSource: 'default',
  heroImage: null,
  imagesSource: 'default',
};

export function createDefaultState(): CanvasState {
  return {
    version: 1,
    sourceUrl: null,
    assets: { ...DEFAULT_ASSETS },
    extractedAt: null,
    lastModified: Date.now(),
  };
}

export function generateMonogram(url: string): string {
  try {
    const domain = new URL(url).hostname.replace('www.', '');
    const initials = domain.split('.')[0].substring(0, 2).toUpperCase();

    return `data:image/svg+xml,${encodeURIComponent(`
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
        <rect width="100" height="100" fill="#111"/>
        <text x="50" y="55" font-family="Inter, sans-serif"
              font-size="40" font-weight="700"
              fill="#FFF" text-anchor="middle" dominant-baseline="middle">
          ${initials}
        </text>
      </svg>
    `)}`;
  } catch {
    return `data:image/svg+xml,${encodeURIComponent(`
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
        <rect width="100" height="100" fill="#111"/>
        <text x="50" y="55" font-family="Inter, sans-serif"
              font-size="40" font-weight="700"
              fill="#FFF" text-anchor="middle" dominant-baseline="middle">
          BB
        </text>
      </svg>
    `)}`;
  }
}
```
  </action>
  <verify>
Files exist: `src/types/brand.ts`, `src/state/defaults.ts`.
TypeScript compilation succeeds (`npm run build` or IDE shows no type errors).
  </verify>
  <done>
Brand types and default values defined with proper TypeScript types.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create state management with dual persistence</name>
  <files>src/state/canvasState.ts, src/state/persistence.ts, src/utils/compression.ts</files>
  <action>
Create `src/utils/compression.ts`:
```typescript
import LZString from 'lz-string';
import type { CanvasState } from '@/types/brand';

export function compressState(state: CanvasState): string {
  // Remove large data URIs before compression - store separately
  const serializable = {
    ...state,
    assets: {
      ...state.assets,
      logo: state.assets.logo?.startsWith('data:')
        ? `ref:${hashString(state.assets.logo)}`
        : state.assets.logo,
      heroImage: state.assets.heroImage?.startsWith('data:')
        ? `ref:${hashString(state.assets.heroImage)}`
        : state.assets.heroImage,
    }
  };

  // Store data URIs in localStorage
  if (state.assets.logo?.startsWith('data:')) {
    const hash = hashString(state.assets.logo);
    try {
      localStorage.setItem(`bb:img:${hash}`, state.assets.logo);
    } catch (e) {
      console.warn('Failed to store logo in localStorage', e);
    }
  }
  if (state.assets.heroImage?.startsWith('data:')) {
    const hash = hashString(state.assets.heroImage);
    try {
      localStorage.setItem(`bb:img:${hash}`, state.assets.heroImage);
    } catch (e) {
      console.warn('Failed to store image in localStorage', e);
    }
  }

  const json = JSON.stringify(serializable);
  const compressed = LZString.compressToEncodedURIComponent(json);

  if (compressed.length > 1800) {
    console.warn(`URL state: ${compressed.length} chars (approaching 2000 limit)`);
  }

  return compressed;
}

export function decompressState(compressed: string): CanvasState | null {
  try {
    const json = LZString.decompressFromEncodedURIComponent(compressed);
    if (!json) return null;

    const state = JSON.parse(json) as CanvasState;

    // Restore data URIs from localStorage
    if (state.assets.logo?.startsWith('ref:')) {
      const hash = state.assets.logo.slice(4);
      state.assets.logo = localStorage.getItem(`bb:img:${hash}`) || null;
    }
    if (state.assets.heroImage?.startsWith('ref:')) {
      const hash = state.assets.heroImage.slice(4);
      state.assets.heroImage = localStorage.getItem(`bb:img:${hash}`) || null;
    }

    return state;
  } catch (error) {
    console.error('Failed to decompress state', error);
    return null;
  }
}

function hashString(str: string): string {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash;
  }
  return Math.abs(hash).toString(36);
}
```

Create `src/state/persistence.ts`:
```typescript
import type { CanvasState } from '@/types/brand';
import { compressState, decompressState } from '@/utils/compression';
import { createDefaultState } from './defaults';

const STORAGE_KEY = 'brandBentoState';

export function syncStateToURL(state: CanvasState): void {
  const compressed = compressState(state);
  const url = new URL(window.location.href);
  url.hash = compressed;
  window.history.replaceState(null, '', url);
}

export function loadStateFromURL(): CanvasState | null {
  const hash = window.location.hash.slice(1);
  if (!hash) return null;
  return decompressState(hash);
}

export function saveStateToLocalStorage(state: CanvasState): void {
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    localStorage.setItem(`${STORAGE_KEY}:timestamp`, Date.now().toString());
  } catch (error) {
    if ((error as Error).name === 'QuotaExceededError') {
      console.warn('localStorage quota exceeded, clearing old data');
      clearOldImageData();
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      } catch (e) {
        console.error('Failed to save state after cleanup', e);
      }
    }
  }
}

export function loadStateFromLocalStorage(): CanvasState | null {
  try {
    const stored = localStorage.getItem(STORAGE_KEY);
    if (!stored) return null;
    return JSON.parse(stored) as CanvasState;
  } catch (error) {
    console.error('Failed to load from localStorage', error);
    return null;
  }
}

export function persistState(state: CanvasState): void {
  syncStateToURL(state);
  saveStateToLocalStorage(state);
}

export function loadState(): CanvasState {
  // URL takes precedence (for sharing)
  const urlState = loadStateFromURL();
  if (urlState) {
    console.log('Loaded state from URL');
    return urlState;
  }

  // Fallback to localStorage
  const localState = loadStateFromLocalStorage();
  if (localState) {
    console.log('Loaded state from localStorage');
    return localState;
  }

  // No state found, use defaults
  console.log('No state found, using defaults');
  return createDefaultState();
}

function clearOldImageData(): void {
  const keysToRemove: string[] = [];
  for (let i = 0; i < localStorage.length; i++) {
    const key = localStorage.key(i);
    if (key?.startsWith('bb:img:')) {
      keysToRemove.push(key);
    }
  }
  keysToRemove.forEach(key => localStorage.removeItem(key));
}
```

Create `src/state/canvasState.ts`:
```typescript
import { create } from 'zustand';
import { subscribeWithSelector } from 'zustand/middleware';
import type { CanvasState, BrandAssets, ExtractionStage } from '@/types/brand';
import { persistState, loadState } from './persistence';
import { DEFAULT_ASSETS, createDefaultState } from './defaults';

interface CanvasStore extends CanvasState {
  // Extraction state
  extractionStage: ExtractionStage;
  extractionError: string | null;

  // Actions
  setAssets: (assets: Partial<BrandAssets>) => void;
  setSourceUrl: (url: string | null) => void;
  setExtractionStage: (stage: ExtractionStage) => void;
  setExtractionError: (error: string | null) => void;
  reset: () => void;

  // Persistence
  hydrate: () => void;
}

export const useCanvasStore = create<CanvasStore>()(
  subscribeWithSelector((set, get) => ({
    // Initial state (will be hydrated)
    ...createDefaultState(),
    extractionStage: 'idle',
    extractionError: null,

    setAssets: (newAssets) => set((state) => ({
      assets: { ...state.assets, ...newAssets },
      lastModified: Date.now(),
    })),

    setSourceUrl: (url) => set({
      sourceUrl: url,
      lastModified: Date.now(),
    }),

    setExtractionStage: (stage) => set({ extractionStage: stage }),

    setExtractionError: (error) => set({
      extractionError: error,
      extractionStage: error ? 'error' : 'idle',
    }),

    reset: () => {
      const current = get();
      set({
        ...createDefaultState(),
        sourceUrl: current.sourceUrl, // Keep URL
        extractionStage: 'idle',
        extractionError: null,
      });
    },

    hydrate: () => {
      const loaded = loadState();
      set({
        ...loaded,
        extractionStage: 'idle',
        extractionError: null,
      });
    },
  }))
);

// Subscribe to state changes and persist
useCanvasStore.subscribe(
  (state) => ({
    version: state.version,
    sourceUrl: state.sourceUrl,
    assets: state.assets,
    extractedAt: state.extractedAt,
    lastModified: state.lastModified,
  }),
  (state) => {
    persistState(state as CanvasState);
  },
  { equalityFn: (a, b) => a.lastModified === b.lastModified }
);
```

Update `src/App.tsx` to hydrate state on mount:
```tsx
import { useEffect } from 'react';
import { useCanvasStore } from '@/state/canvasState';

function App() {
  const hydrate = useCanvasStore((state) => state.hydrate);
  const assets = useCanvasStore((state) => state.assets);
  const sourceUrl = useCanvasStore((state) => state.sourceUrl);

  useEffect(() => {
    hydrate();
  }, [hydrate]);

  return (
    <div className="app">
      <h1>Brand Bento</h1>
      <p>Primary font: {assets.primaryFont}</p>
      <p>Secondary font: {assets.secondaryFont}</p>
      <p>Colors: {assets.colors.join(', ')}</p>
      <p>Source: {sourceUrl || 'None'}</p>
    </div>
  );
}

export default App;
```
  </action>
  <verify>
`npm run dev` starts without errors.
Open browser DevTools > Application > localStorage and see `brandBentoState` key.
Modify state in React DevTools and see localStorage update.
Add `#test` to URL, reload, see state loads from URL (with fallback since test is invalid compressed data).
  </verify>
  <done>
Zustand store created with dual persistence (localStorage + URL hash). State auto-saves on change.
  </done>
</task>

</tasks>

<verification>
1. `npm run dev` starts the app without errors
2. `npm run build` completes without TypeScript errors
3. localStorage shows `brandBentoState` key after page load
4. URL hash updates when state changes
5. Refreshing page restores state from localStorage
6. Opening URL with hash restores state from URL
</verification>

<success_criteria>
- React + Vite + TypeScript project running
- Zustand store managing canvas state
- State persists to localStorage automatically
- State compresses to URL hash via lz-string
- URL state under 2000 characters with typical canvas data
- Type definitions for BrandAssets and CanvasState
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-extraction/01-02-SUMMARY.md`
</output>
