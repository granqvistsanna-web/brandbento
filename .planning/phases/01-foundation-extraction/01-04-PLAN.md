---
phase: 01-foundation-extraction
plan: 04
type: execute
wave: 3
depends_on: [02, 03]
files_modified:
  - src/components/URLInput.tsx
  - src/components/Tile.tsx
  - src/components/ExtractionOverlay.tsx
  - src/App.tsx
  - src/App.css
autonomous: false

must_haves:
  truths:
    - "User can enter a URL in an input field and trigger extraction"
    - "Tiles show shimmer loading state during extraction"
    - "Tiles display extracted or default content after extraction completes"
    - "Tiles with default content show 'Default - click to change' badge"
    - "Extraction progress is visible to user (loading states per tile)"
  artifacts:
    - path: "src/components/URLInput.tsx"
      provides: "URL input with extraction trigger"
      min_lines: 30
    - path: "src/components/Tile.tsx"
      provides: "Base tile with shimmer and default badge"
      min_lines: 50
    - path: "src/App.tsx"
      provides: "Main app wiring URL input to extraction"
      min_lines: 60
  key_links:
    - from: "src/App.tsx"
      to: "src/services/brandExtractor.ts"
      via: "extractBrand call"
      pattern: "extractBrand"
    - from: "src/App.tsx"
      to: "src/state/canvasState.ts"
      via: "setAssets on extraction complete"
      pattern: "setAssets"
---

<objective>
Create URL input component and shimmer-loading tiles that connect extraction services to the UI.

Purpose: Enable users to enter a website URL and see brand assets populate progressively. This completes the Phase 1 extraction flow from URL input through to populated canvas.

Output: Working extraction flow with URL input, shimmer loading states, and tiles that display extracted or default content with appropriate badges.
</objective>

<execution_context>
@/Users/sannagranqvist/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sannagranqvist/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-extraction/01-RESEARCH.md
@.planning/phases/01-foundation-extraction/01-02-SUMMARY.md
@.planning/phases/01-foundation-extraction/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create URL input and tile components</name>
  <files>src/components/URLInput.tsx, src/components/Tile.tsx, src/components/ExtractionOverlay.tsx</files>
  <action>
Create `src/components/URLInput.tsx`:
```tsx
import { useState, FormEvent } from 'react';

interface URLInputProps {
  onSubmit: (url: string) => void;
  disabled?: boolean;
  initialValue?: string;
}

export function URLInput({ onSubmit, disabled, initialValue = '' }: URLInputProps) {
  const [url, setUrl] = useState(initialValue);
  const [error, setError] = useState<string | null>(null);

  const handleSubmit = (e: FormEvent) => {
    e.preventDefault();
    setError(null);

    const trimmed = url.trim();
    if (!trimmed) {
      setError('Please enter a URL');
      return;
    }

    // Basic URL validation
    let fullUrl = trimmed;
    if (!trimmed.startsWith('http://') && !trimmed.startsWith('https://')) {
      fullUrl = 'https://' + trimmed;
    }

    try {
      new URL(fullUrl);
      onSubmit(fullUrl);
    } catch {
      setError('Please enter a valid URL');
    }
  };

  return (
    <form onSubmit={handleSubmit} className="url-input-form">
      <div className="url-input-wrapper">
        <input
          type="text"
          value={url}
          onChange={(e) => setUrl(e.target.value)}
          placeholder="Enter website URL (e.g., stripe.com)"
          disabled={disabled}
          className="url-input"
          aria-label="Website URL"
        />
        <button
          type="submit"
          disabled={disabled || !url.trim()}
          className="url-submit-button"
        >
          {disabled ? 'Extracting...' : 'Extract Brand'}
        </button>
      </div>
      {error && <p className="url-input-error">{error}</p>}
    </form>
  );
}
```

Create `src/components/Tile.tsx`:
```tsx
import Skeleton from 'react-loading-skeleton';
import 'react-loading-skeleton/dist/skeleton.css';

interface TileProps {
  children: React.ReactNode;
  isLoading?: boolean;
  isDefault?: boolean;
  label?: string;
  onClick?: () => void;
  className?: string;
}

export function Tile({
  children,
  isLoading = false,
  isDefault = false,
  label,
  onClick,
  className = ''
}: TileProps) {
  if (isLoading) {
    return (
      <div className={`tile tile-loading ${className}`}>
        <Skeleton
          height="100%"
          borderRadius={12}
          baseColor="#f0f0f0"
          highlightColor="#fafafa"
        />
      </div>
    );
  }

  return (
    <div
      className={`tile ${isDefault ? 'tile-default' : ''} ${className}`}
      onClick={onClick}
      role={onClick ? 'button' : undefined}
      tabIndex={onClick ? 0 : undefined}
    >
      {isDefault && (
        <div className="tile-default-badge">
          Default â€” click to change
        </div>
      )}
      {label && <div className="tile-label">{label}</div>}
      <div className="tile-content">
        {children}
      </div>
    </div>
  );
}

// Specialized tile variants
export function ColorTile({
  colors,
  isLoading,
  isDefault,
  onClick
}: {
  colors: string[];
  isLoading?: boolean;
  isDefault?: boolean;
  onClick?: () => void;
}) {
  return (
    <Tile
      isLoading={isLoading}
      isDefault={isDefault}
      label="Colors"
      onClick={onClick}
      className="tile-colors"
    >
      <div className="color-swatches">
        {colors.map((color, i) => (
          <div
            key={i}
            className="color-swatch"
            style={{ backgroundColor: color }}
            title={color}
          />
        ))}
      </div>
    </Tile>
  );
}

export function FontTile({
  fontName,
  variant,
  isLoading,
  isDefault,
  onClick
}: {
  fontName: string;
  variant: 'primary' | 'secondary';
  isLoading?: boolean;
  isDefault?: boolean;
  onClick?: () => void;
}) {
  return (
    <Tile
      isLoading={isLoading}
      isDefault={isDefault}
      label={variant === 'primary' ? 'Primary Type' : 'Secondary Type'}
      onClick={onClick}
      className={`tile-font tile-font-${variant}`}
    >
      <div className="font-specimen" style={{ fontFamily: fontName }}>
        <span className="font-name">{fontName}</span>
        <span className="font-sample">
          {variant === 'primary' ? 'Aa' : 'The quick brown fox'}
        </span>
      </div>
    </Tile>
  );
}

export function LogoTile({
  logo,
  isLoading,
  isDefault,
  onClick
}: {
  logo: string | null;
  isLoading?: boolean;
  isDefault?: boolean;
  onClick?: () => void;
}) {
  return (
    <Tile
      isLoading={isLoading}
      isDefault={isDefault}
      label="Logo"
      onClick={onClick}
      className="tile-logo"
    >
      {logo ? (
        <img src={logo} alt="Brand logo" className="logo-image" />
      ) : (
        <div className="logo-placeholder">No logo</div>
      )}
    </Tile>
  );
}

export function ImageTile({
  image,
  colors,
  isLoading,
  isDefault,
  onClick
}: {
  image: string | null;
  colors: string[];
  isLoading?: boolean;
  isDefault?: boolean;
  onClick?: () => void;
}) {
  // Generate gradient from colors if no image
  const gradient = colors.length >= 2
    ? `linear-gradient(135deg, ${colors[0]} 0%, ${colors[1]} 100%)`
    : 'linear-gradient(135deg, #2563EB 0%, #7C3AED 100%)';

  return (
    <Tile
      isLoading={isLoading}
      isDefault={isDefault}
      label="Imagery"
      onClick={onClick}
      className="tile-imagery"
    >
      {image ? (
        <img src={image} alt="Brand imagery" className="imagery-image" />
      ) : (
        <div className="imagery-gradient" style={{ background: gradient }} />
      )}
    </Tile>
  );
}
```

Create `src/components/ExtractionOverlay.tsx`:
```tsx
import type { ExtractionStage } from '@/types/brand';

interface ExtractionOverlayProps {
  stage: ExtractionStage;
  error: string | null;
  onDismiss?: () => void;
}

const STAGE_MESSAGES: Record<ExtractionStage, string> = {
  idle: '',
  fetching: 'Fetching page...',
  colors: 'Extracting colors...',
  fonts: 'Extracting typography...',
  images: 'Finding imagery...',
  logo: 'Detecting logo...',
  complete: 'Extraction complete!',
  error: 'Extraction failed',
};

export function ExtractionOverlay({ stage, error, onDismiss }: ExtractionOverlayProps) {
  if (stage === 'idle' || stage === 'complete') {
    return null;
  }

  return (
    <div className="extraction-overlay">
      <div className="extraction-status">
        {stage === 'error' ? (
          <>
            <span className="extraction-error-icon">!</span>
            <p className="extraction-error-message">{error || 'Something went wrong'}</p>
            {onDismiss && (
              <button onClick={onDismiss} className="extraction-dismiss">
                Continue with defaults
              </button>
            )}
          </>
        ) : (
          <>
            <div className="extraction-spinner" />
            <p className="extraction-message">{STAGE_MESSAGES[stage]}</p>
          </>
        )}
      </div>
    </div>
  );
}
```

Create export barrel `src/components/index.ts`:
```typescript
export { URLInput } from './URLInput';
export { Tile, ColorTile, FontTile, LogoTile, ImageTile } from './Tile';
export { ExtractionOverlay } from './ExtractionOverlay';
```
  </action>
  <verify>
Files exist: `src/components/URLInput.tsx`, `src/components/Tile.tsx`, `src/components/ExtractionOverlay.tsx`.
No TypeScript errors.
  </verify>
  <done>
URL input and tile components created with shimmer loading and default badge support.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire up extraction flow in App</name>
  <files>src/App.tsx, src/App.css</files>
  <action>
Update `src/App.tsx`:
```tsx
import { useEffect, useCallback } from 'react';
import { useCanvasStore } from '@/state/canvasState';
import { extractBrand, ExtractionProgress } from '@/services/brandExtractor';
import { URLInput, ColorTile, FontTile, LogoTile, ImageTile, ExtractionOverlay } from '@/components';
import './App.css';

function App() {
  const hydrate = useCanvasStore((state) => state.hydrate);
  const assets = useCanvasStore((state) => state.assets);
  const sourceUrl = useCanvasStore((state) => state.sourceUrl);
  const extractionStage = useCanvasStore((state) => state.extractionStage);
  const extractionError = useCanvasStore((state) => state.extractionError);

  const setAssets = useCanvasStore((state) => state.setAssets);
  const setSourceUrl = useCanvasStore((state) => state.setSourceUrl);
  const setExtractionStage = useCanvasStore((state) => state.setExtractionStage);
  const setExtractionError = useCanvasStore((state) => state.setExtractionError);

  useEffect(() => {
    hydrate();
  }, [hydrate]);

  const handleExtract = useCallback(async (url: string) => {
    setSourceUrl(url);
    setExtractionError(null);
    setExtractionStage('fetching');

    try {
      const result = await extractBrand(url, (progress: ExtractionProgress) => {
        setExtractionStage(progress.stage);
        if (progress.assets) {
          setAssets(progress.assets);
        }
        if (progress.error) {
          setExtractionError(progress.error);
        }
      });

      setAssets(result);
      setExtractionStage('complete');

      // Clear complete status after a moment
      setTimeout(() => {
        setExtractionStage('idle');
      }, 1500);

    } catch (error) {
      const message = error instanceof Error ? error.message : 'Extraction failed';
      setExtractionError(message);
      setExtractionStage('error');
    }
  }, [setAssets, setSourceUrl, setExtractionStage, setExtractionError]);

  const handleDismissError = useCallback(() => {
    setExtractionStage('idle');
    setExtractionError(null);
  }, [setExtractionStage, setExtractionError]);

  const isExtracting = extractionStage !== 'idle' && extractionStage !== 'complete' && extractionStage !== 'error';

  // Determine which tiles are still loading
  const tileLoading = {
    colors: extractionStage === 'fetching' || extractionStage === 'colors',
    fonts: extractionStage === 'fetching' || extractionStage === 'colors' || extractionStage === 'fonts',
    images: extractionStage === 'fetching' || extractionStage === 'colors' || extractionStage === 'fonts' || extractionStage === 'images',
    logo: extractionStage === 'fetching' || extractionStage === 'colors' || extractionStage === 'fonts' || extractionStage === 'images' || extractionStage === 'logo',
  };

  return (
    <div className="app">
      <header className="app-header">
        <h1 className="app-title">Brand Bento</h1>
        <p className="app-subtitle">Extract and remix brand assets</p>
      </header>

      <main className="app-main">
        <URLInput
          onSubmit={handleExtract}
          disabled={isExtracting}
          initialValue={sourceUrl || ''}
        />

        <div className="canvas-preview">
          <div className="tile-grid">
            <LogoTile
              logo={assets.logo}
              isLoading={isExtracting && tileLoading.logo}
              isDefault={assets.logoSource === 'default'}
            />

            <FontTile
              fontName={assets.primaryFont}
              variant="primary"
              isLoading={isExtracting && tileLoading.fonts}
              isDefault={assets.fontsSource === 'default'}
            />

            <ImageTile
              image={assets.heroImage}
              colors={assets.colors}
              isLoading={isExtracting && tileLoading.images}
              isDefault={assets.imagesSource === 'default'}
            />

            <ColorTile
              colors={assets.colors}
              isLoading={isExtracting && tileLoading.colors}
              isDefault={assets.colorsSource === 'default'}
            />

            <FontTile
              fontName={assets.secondaryFont}
              variant="secondary"
              isLoading={isExtracting && tileLoading.fonts}
              isDefault={assets.fontsSource === 'default'}
            />
          </div>
        </div>

        <ExtractionOverlay
          stage={extractionStage}
          error={extractionError}
          onDismiss={handleDismissError}
        />
      </main>
    </div>
  );
}

export default App;
```

Create `src/App.css`:
```css
:root {
  --color-bg: #FAFAFA;
  --color-surface: #FFFFFF;
  --color-text: #111111;
  --color-text-muted: #666666;
  --color-primary: #2563EB;
  --color-border: #E5E5E5;
  --radius-sm: 8px;
  --radius-md: 12px;
  --radius-lg: 16px;
  --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
  --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.05), 0 2px 4px rgba(0, 0, 0, 0.05);
}

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
  background: var(--color-bg);
  color: var(--color-text);
  line-height: 1.5;
}

.app {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

/* Header */
.app-header {
  text-align: center;
  padding: 3rem 1rem 2rem;
}

.app-title {
  font-size: 2rem;
  font-weight: 700;
  letter-spacing: -0.02em;
}

.app-subtitle {
  color: var(--color-text-muted);
  margin-top: 0.5rem;
}

/* Main */
.app-main {
  flex: 1;
  padding: 0 1rem 3rem;
  max-width: 800px;
  margin: 0 auto;
  width: 100%;
}

/* URL Input */
.url-input-form {
  margin-bottom: 2rem;
}

.url-input-wrapper {
  display: flex;
  gap: 0.5rem;
  background: var(--color-surface);
  padding: 0.5rem;
  border-radius: var(--radius-lg);
  box-shadow: var(--shadow-md);
  border: 1px solid var(--color-border);
}

.url-input {
  flex: 1;
  padding: 0.75rem 1rem;
  border: none;
  border-radius: var(--radius-md);
  font-size: 1rem;
  background: transparent;
  outline: none;
}

.url-input:focus {
  background: var(--color-bg);
}

.url-submit-button {
  padding: 0.75rem 1.5rem;
  background: var(--color-primary);
  color: white;
  border: none;
  border-radius: var(--radius-md);
  font-size: 1rem;
  font-weight: 500;
  cursor: pointer;
  transition: opacity 0.2s;
}

.url-submit-button:hover:not(:disabled) {
  opacity: 0.9;
}

.url-submit-button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.url-input-error {
  color: #DC2626;
  font-size: 0.875rem;
  margin-top: 0.5rem;
  padding-left: 1rem;
}

/* Canvas Preview */
.canvas-preview {
  background: var(--color-surface);
  border-radius: var(--radius-lg);
  padding: 1.5rem;
  box-shadow: var(--shadow-md);
  border: 1px solid var(--color-border);
}

/* Tile Grid - simplified preview layout */
.tile-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 1rem;
}

/* Tiles */
.tile {
  position: relative;
  background: var(--color-bg);
  border-radius: var(--radius-md);
  padding: 1rem;
  min-height: 120px;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  transition: transform 0.2s, box-shadow 0.2s;
}

.tile:hover {
  transform: translateY(-2px);
  box-shadow: var(--shadow-md);
}

.tile-loading {
  padding: 0;
}

.tile-label {
  font-size: 0.75rem;
  font-weight: 500;
  color: var(--color-text-muted);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  margin-bottom: 0.5rem;
}

.tile-content {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
}

.tile-default-badge {
  position: absolute;
  top: 0.5rem;
  right: 0.5rem;
  padding: 0.25rem 0.5rem;
  background: rgba(0, 0, 0, 0.05);
  border-radius: var(--radius-sm);
  font-size: 0.625rem;
  color: var(--color-text-muted);
  white-space: nowrap;
}

/* Color tile */
.color-swatches {
  display: flex;
  gap: 0.25rem;
  flex-wrap: wrap;
}

.color-swatch {
  width: 32px;
  height: 32px;
  border-radius: var(--radius-sm);
  border: 1px solid rgba(0, 0, 0, 0.1);
}

/* Font tile */
.font-specimen {
  text-align: center;
}

.font-name {
  display: block;
  font-size: 0.75rem;
  color: var(--color-text-muted);
  margin-bottom: 0.25rem;
}

.font-sample {
  font-size: 1.5rem;
  font-weight: 500;
}

.tile-font-secondary .font-sample {
  font-size: 0.875rem;
  font-weight: 400;
}

/* Logo tile */
.logo-image {
  max-width: 80%;
  max-height: 60px;
  object-fit: contain;
}

.logo-placeholder {
  color: var(--color-text-muted);
  font-size: 0.875rem;
}

/* Imagery tile */
.tile-imagery {
  grid-column: span 1;
  grid-row: span 2;
  min-height: 260px;
}

.imagery-image {
  width: 100%;
  height: 100%;
  object-fit: cover;
  border-radius: var(--radius-sm);
}

.imagery-gradient {
  width: 100%;
  height: 100%;
  border-radius: var(--radius-sm);
  min-height: 100px;
}

/* Extraction overlay */
.extraction-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(255, 255, 255, 0.9);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 100;
}

.extraction-status {
  text-align: center;
  padding: 2rem;
}

.extraction-spinner {
  width: 40px;
  height: 40px;
  border: 3px solid var(--color-border);
  border-top-color: var(--color-primary);
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin: 0 auto 1rem;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

.extraction-message {
  color: var(--color-text-muted);
  font-size: 1rem;
}

.extraction-error-icon {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 40px;
  height: 40px;
  background: #FEE2E2;
  color: #DC2626;
  border-radius: 50%;
  font-weight: 700;
  margin-bottom: 1rem;
}

.extraction-error-message {
  color: #DC2626;
  margin-bottom: 1rem;
}

.extraction-dismiss {
  padding: 0.5rem 1rem;
  background: var(--color-primary);
  color: white;
  border: none;
  border-radius: var(--radius-sm);
  cursor: pointer;
}

/* Responsive */
@media (max-width: 640px) {
  .tile-grid {
    grid-template-columns: 1fr;
  }

  .tile-imagery {
    grid-column: span 1;
    grid-row: span 1;
    min-height: 150px;
  }

  .url-input-wrapper {
    flex-direction: column;
  }

  .url-submit-button {
    width: 100%;
  }
}
```
  </action>
  <verify>
`npm run dev` starts without errors.
App renders with URL input and tile grid.
Entering a URL triggers extraction (requires Plan 01 CORS proxy to be deployed).
  </verify>
  <done>
App wired to extraction flow with URL input, shimmer loading, and progressive tile updates.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete Phase 1 extraction flow:
1. URL input form
2. Shimmer loading states during extraction
3. Tile display with extracted or default content
4. "Default - click to change" badges on fallback tiles
5. Progressive extraction updates
  </what-built>
  <how-to-verify>
1. Start the dev server: `npm run dev`
2. Open browser to http://localhost:5173
3. Verify you see the URL input and empty tiles with defaults
4. Enter a URL (e.g., "stripe.com") and click "Extract Brand"
5. Verify:
   - Extraction overlay appears with progress messages
   - Tiles show shimmer loading states
   - Tiles progressively populate with content
   - If extraction fails, tiles show defaults with "Default - click to change" badge
6. Refresh the page - state should restore from localStorage
7. Copy the URL (includes hash) and open in new tab - state should restore

**Note:** If CORS proxy not deployed yet, extraction will fail but should gracefully show defaults.
  </how-to-verify>
  <resume-signal>Type "approved" if extraction flow works, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
1. `npm run dev` starts without errors
2. URL input accepts URLs and triggers extraction
3. Tiles show shimmer during extraction
4. Tiles display content after extraction
5. Default badges appear on fallback content
6. State persists in localStorage and URL hash
7. Refreshing restores state
</verification>

<success_criteria>
- User can enter a URL and see extraction begin
- Shimmer loading states appear during extraction
- Tiles populate progressively as extraction completes
- Extraction failures show defaults with badge
- State persists across page refresh
- URL hash enables sharing
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-extraction/01-04-SUMMARY.md`
</output>
