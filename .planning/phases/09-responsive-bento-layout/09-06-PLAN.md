---
phase: 09-responsive-bento-layout
plan: 06
type: execute
wave: 3
depends_on: ["09-02"]
files_modified:
  - src/utils/layoutFit.ts
  - src/components/BentoGrid.tsx
autonomous: true

must_haves:
  truths:
    - "Tiles that don't fit in grid are gracefully hidden"
    - "Grid works correctly with 6-14 tiles"
    - "Large tiles reduce spans when grid is constrained"
  artifacts:
    - path: "src/utils/layoutFit.ts"
      provides: "Tile fitting logic with span reduction and hiding"
      exports: ["fitTilesToGrid", "reduceTileSpans"]
      min_lines: 40
  key_links:
    - from: "src/components/BentoGrid.tsx"
      to: "src/utils/layoutFit.ts"
      via: "fitTilesToGrid function"
      pattern: "fitTilesToGrid"
---

<objective>
Add graceful degradation logic for tiles that don't fit in the grid.

Purpose: Handle edge cases where tile spans exceed available grid space or tile count varies (SC#6, SC#10).
Output: Layout fitting utility and integration with BentoGrid.
</objective>

<execution_context>
@/Users/sannagranqvist/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sannagranqvist/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/09-responsive-bento-layout/09-RESEARCH.md
@.planning/phases/09-responsive-bento-layout/09-02-SUMMARY.md
@src/components/BentoGrid.tsx
@src/config/layoutPresets.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create layout fitting utility</name>
  <files>src/utils/layoutFit.ts</files>
  <action>
Create utility functions for graceful tile fitting:

1. `reduceTileSpans(tile, maxCols, maxRows)`: Reduces a tile's spans to fit within constraints
   - If colSpan > maxCols, reduce to maxCols
   - If rowSpan > maxRows, reduce to maxRows
   - Returns modified tile with reduced spans

2. `fitTilesToGrid(tiles, gridConfig, breakpoint)`: Main fitting function
   - Takes array of tiles with their span configurations
   - Takes grid configuration (columns, rows from preset)
   - Returns { visibleTiles, hiddenTiles }

   Algorithm:
   - Calculate total grid cells available (columns * rows)
   - Sort tiles by priority (hero > content tiles > utility)
   - For each tile, try to fit it:
     - If tile spans exceed grid, reduce spans via reduceTileSpans
     - If no space remaining, add to hiddenTiles
   - Return visible and hidden tile lists

3. `getTilePriority(tileType)`: Returns priority number for tile types
   - hero: 1 (highest)
   - logo, colors, primaryType, secondaryType: 2
   - imagery, uiPreview, editorial, product: 3
   - utility: 4 (lowest, hide first)

Export type: TileFitResult = { visibleTiles: Tile[], hiddenTiles: Tile[] }

Handle 6-14 tile range by:
- Presets define 9 standard tiles
- Extra tiles (10-14) get 1x1 spans and fill remaining cells
- Below 9 tiles: larger tiles expand to fill space
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit src/utils/layoutFit.ts`
  </verify>
  <done>
Layout fitting utility created with span reduction and priority-based hiding.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate fitting logic into BentoGrid</name>
  <files>src/components/BentoGrid.tsx</files>
  <action>
Update BentoGrid to use layout fitting:

1. Import fitTilesToGrid from utils/layoutFit
2. Accept tiles array as prop (not just children)
3. Apply fitting logic before rendering:
   - Call fitTilesToGrid with tiles, current preset config, and breakpoint
   - Render only visibleTiles
   - Optionally show hidden tile count in debug mode

Update BentoGrid interface:
```typescript
interface BentoGridProps {
  tiles: TileData[];  // Instead of children
  renderTile: (tile: TileData, adjustedSpan: TileSpan) => ReactNode;
  className?: string;
}
```

In render:
- Call fitTilesToGrid(tiles, config, breakpoint)
- Map over result.visibleTiles
- Pass adjusted spans to renderTile callback
- If debugMode and hiddenTiles.length > 0, show indicator

This enables graceful handling of:
- Tiles with spans too large for current breakpoint
- More tiles than grid cells available
- Dynamic tile counts (6-14 range)
  </action>
  <verify>
Run dev server:
1. Add extra tiles beyond preset capacity
2. Verify overflow tiles are hidden, not breaking layout
3. Resize to mobile - large tiles reduce spans
  </verify>
  <done>
BentoGrid integrates fitting logic for graceful degradation.
  </done>
</task>

</tasks>

<verification>
1. Tiles that don't fit are hidden gracefully (no layout break)
2. Large tiles reduce spans on smaller breakpoints
3. Priority system hides utility tiles before content tiles
4. Grid works with 6-14 tiles
</verification>

<success_criteria>
- src/utils/layoutFit.ts exports fitTilesToGrid and reduceTileSpans
- BentoGrid uses fitting logic to handle overflow
- No tile overflow or layout breaks with variable tile counts
- Debug mode shows hidden tile count when applicable
</success_criteria>

<output>
After completion, create `.planning/phases/09-responsive-bento-layout/09-06-SUMMARY.md`
</output>
